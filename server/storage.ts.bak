import { 
  User, InsertUser, Branch, InsertBranch, MonthlyTarget, InsertMonthlyTarget,
  DailySales, InsertDailySales, Activity, InsertActivity, Notification, InsertNotification,
  ConsolidatedDailySales, InsertConsolidatedDailySales, DashboardStats,
  
  // Ø£Ù†ÙˆØ§Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ²
  RewardPoints, InsertRewardPoints, RewardPointsHistory, InsertRewardPointsHistory,
  Achievement, InsertAchievement, UserAchievement, InsertUserAchievement,
  Reward, InsertReward, RewardRedemption, InsertRewardRedemption,
  Leaderboard, InsertLeaderboard, LeaderboardResult, InsertLeaderboardResult,
  
  users, branches, monthlyTargets, dailySales, activities, notifications, consolidatedDailySales,
  rewardPoints, rewardPointsHistory, achievements, userAchievements, rewards, rewardRedemptions,
  leaderboards, leaderboardResults
} from "@shared/schema";
import { format, addDays, startOfWeek, endOfWeek, startOfMonth, endOfMonth, parseISO, subDays, subMonths, subYears } from "date-fns";
import { ar } from "date-fns/locale";
import { db } from "./db";
import { eq, and, gte, lte, desc, asc, sql } from "drizzle-orm";

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  // Users
  getUser(id: number): Promise<User | undefined>;
  getUsers(): Promise<User[]>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, user: Partial<User>): Promise<User | undefined>;
  deleteUser(id: number): Promise<boolean>;
  
  // Branches
  getBranch(id: number): Promise<Branch | undefined>;
  getBranches(): Promise<Branch[]>;
  createBranch(branch: InsertBranch): Promise<Branch>;
  updateBranch(id: number, branch: Partial<Branch>): Promise<Branch | undefined>;
  
  // Monthly Targets
  getMonthlyTarget(id: number): Promise<MonthlyTarget | undefined>;
  getMonthlyTargets(): Promise<MonthlyTarget[]>;
  getMonthlyTargetByBranchAndDate(branchId: number, month: number, year: number): Promise<MonthlyTarget | undefined>;
  createMonthlyTarget(target: InsertMonthlyTarget): Promise<MonthlyTarget>;
  
  // Daily Sales
  getDailySales(): Promise<DailySales[]>;
  getDailySalesById(id: number): Promise<DailySales | undefined>;
  getDailySalesByBranchAndDate(branchId: number, date: string): Promise<DailySales[]>;
  getDailySalesByBranchAndDateRange(branchId: number, startDate: string, endDate: string): Promise<DailySales[]>;
  getDailySalesByCashierAndDate(cashierId: number, date: string): Promise<DailySales | undefined>;
  createDailySales(sales: InsertDailySales): Promise<DailySales>;
  
  // Activities
  getActivities(limit?: number): Promise<Activity[]>;
  getActivitiesByBranch(branchId: number, limit?: number): Promise<Activity[]>;
  createActivity(activity: InsertActivity): Promise<Activity>;
  
  // Notifications
  getNotifications(limit?: number): Promise<Notification[]>;
  getNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]>;
  getUnreadNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]>;
  markNotificationAsRead(id: number): Promise<Notification | undefined>;
  createNotification(notification: InsertNotification): Promise<Notification>;
  
  // Consolidated Daily Sales
  getConsolidatedDailySales(): Promise<ConsolidatedDailySales[]>;
  getConsolidatedDailySalesByBranch(branchId: number): Promise<ConsolidatedDailySales[]>;
  getConsolidatedDailySalesByDate(date: string): Promise<ConsolidatedDailySales[]>;
  getConsolidatedDailySalesById(id: number): Promise<ConsolidatedDailySales | undefined>;
  createConsolidatedDailySales(consolidatedSales: InsertConsolidatedDailySales): Promise<ConsolidatedDailySales>;
  closeConsolidatedDailySales(id: number, userId: number): Promise<ConsolidatedDailySales | undefined>;
  
  // Daily Sales Operations
  checkExistingDailySales(cashierId: number, date: string): Promise<boolean>;
  updateDailySalesStatus(id: number, status: string, consolidatedId?: number): Promise<DailySales | undefined>;
  consolidateDailySales(branchId: number, date: string, userId: number): Promise<ConsolidatedDailySales | undefined>;
  
  // Dashboard Stats
  getDashboardStats(branchId: number, date: Date): Promise<DashboardStats>;
  getBranchTargetAchievement(month: number, year: number): Promise<any[]>;
  getCashierPerformance(branchId: number, date: Date): Promise<any[]>;
  getSalesAnalytics(branchId: number, period: string): Promise<any>;
  
  // Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ù†Ù‚Ø§Ø·
  // Reward Points
  getUserRewardPoints(userId: number): Promise<RewardPoints | undefined>;
  updateUserRewardPoints(userId: number, points: number): Promise<RewardPoints | undefined>;
  addRewardPointsHistory(history: InsertRewardPointsHistory): Promise<RewardPointsHistory>;
  getRewardPointsHistory(userId: number, limit?: number): Promise<RewardPointsHistory[]>;
  getRewardPointsHistoryByType(userId: number, type: string): Promise<RewardPointsHistory[]>;
  
  // Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª
  // Achievements
  getAllAchievements(): Promise<Achievement[]>;
  getAchievement(id: number): Promise<Achievement | undefined>;
  getAchievementsByCategory(category: string): Promise<Achievement[]>;
  createAchievement(achievement: InsertAchievement): Promise<Achievement>;
  updateAchievement(id: number, achievement: Partial<Achievement>): Promise<Achievement | undefined>;
  
  // Ø¥Ù†Ø¬Ø§Ø²Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  // User Achievements
  getUserAchievements(userId: number): Promise<UserAchievement[]>;
  assignAchievementToUser(userAchievement: InsertUserAchievement): Promise<UserAchievement>;
  updateUserAchievementProgress(userId: number, achievementId: number, progress: number): Promise<UserAchievement | undefined>;
  completeUserAchievement(userId: number, achievementId: number): Promise<UserAchievement | undefined>;
  
  // Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  // Rewards
  getAllRewards(): Promise<Reward[]>;
  getReward(id: number): Promise<Reward | undefined>;
  getRewardsByCategory(category: string): Promise<Reward[]>;
  createReward(reward: InsertReward): Promise<Reward>;
  updateReward(id: number, reward: Partial<Reward>): Promise<Reward | undefined>;
  
  // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  // Reward Redemptions
  getUserRedemptions(userId: number): Promise<RewardRedemption[]>;
  createRedemption(redemption: InsertRewardRedemption): Promise<RewardRedemption>;
  approveRedemption(id: number, approverId: number): Promise<RewardRedemption | undefined>;
  rejectRedemption(id: number, notes?: string): Promise<RewardRedemption | undefined>;
  getRedemptionsByStatus(status: string): Promise<RewardRedemption[]>;
  
  // Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
  // Leaderboards
  getActiveLeaderboards(): Promise<Leaderboard[]>;
  getLeaderboard(id: number): Promise<Leaderboard | undefined>;
  createLeaderboard(leaderboard: InsertLeaderboard): Promise<Leaderboard>;
  updateLeaderboardResults(leaderboardId: number, results: InsertLeaderboardResult[]): Promise<LeaderboardResult[]>;
  getLeaderboardResults(leaderboardId: number): Promise<LeaderboardResult[]>;
  getUserLeaderboardRank(leaderboardId: number, userId: number): Promise<LeaderboardResult | undefined>;
  
  // ÙˆØ¸Ø§Ø¦Ù ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  // Sales Analysis
  analyzeSalesDrops(branchId: number, period: string): Promise<any>;
  generateSalesAlerts(branchId: number, threshold: number): Promise<any[]>;
  analyzeCashierPerformanceTrends(branchId: number, period: string): Promise<any[]>;
  
  // Demo data
  initializeDemoData(): Promise<void>;
  
  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
   * Ø¥Ø°Ø§ ÙƒØ§Ù† branchId = 0ØŒ ÙØ³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø£Ø¯Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹
   * @param branchId Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±Ø¹ (0 Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹)
   * @param date Ø§Ù„ØªØ§Ø±ÙŠØ®
   */
  getCashierPerformance(branchId: number, date: Date): Promise<any[]>;
}

export class MemStorage implements IStorage {
  private users: Map<number, User>;
  private branches: Map<number, Branch>;
  private monthlyTargets: Map<number, MonthlyTarget>;
  private dailySales: Map<number, DailySales>;
  private activities: Map<number, Activity>;
  private notifications: Map<number, Notification>;
  private consolidatedDailySales: Map<number, ConsolidatedDailySales>;
  
  // Ø®Ø±Ø§Ø¦Ø· Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ²
  private rewardPoints: Map<number, RewardPoints>;
  private rewardPointsHistory: Map<number, RewardPointsHistory>;
  private achievements: Map<number, Achievement>;
  private userAchievements: Map<number, UserAchievement>;
  private rewards: Map<number, Reward>;
  private rewardRedemptions: Map<number, RewardRedemption>;
  private leaderboards: Map<number, Leaderboard>;
  private leaderboardResults: Map<number, LeaderboardResult>;
  
  private userCurrentId: number;
  private branchCurrentId: number;
  private targetCurrentId: number;
  private salesCurrentId: number;
  private activityCurrentId: number;
  private notificationCurrentId: number;
  private consolidatedSalesCurrentId: number;
  
  // Ù…Ø¹Ø±ÙØ§Øª Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ²
  private rewardPointsCurrentId: number;
  private rewardPointsHistoryCurrentId: number;
  private achievementsCurrentId: number;
  private userAchievementsCurrentId: number;
  private rewardsCurrentId: number;
  private rewardRedemptionsCurrentId: number;
  private leaderboardsCurrentId: number;
  private leaderboardResultsCurrentId: number;
  
  constructor() {
    this.users = new Map();
    this.branches = new Map();
    this.monthlyTargets = new Map();
    this.dailySales = new Map();
    this.activities = new Map();
    this.notifications = new Map();
    this.consolidatedDailySales = new Map();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±Ø§Ø¦Ø· Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ²
    this.rewardPoints = new Map();
    this.rewardPointsHistory = new Map();
    this.achievements = new Map();
    this.userAchievements = new Map();
    this.rewards = new Map();
    this.rewardRedemptions = new Map();
    this.leaderboards = new Map();
    this.leaderboardResults = new Map();
    
    this.userCurrentId = 1;
    this.branchCurrentId = 1;
    this.targetCurrentId = 1;
    this.salesCurrentId = 1;
    this.activityCurrentId = 1;
    this.notificationCurrentId = 1;
    this.consolidatedSalesCurrentId = 1;
    
    // Ù…Ø¹Ø±ÙØ§Øª Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ²
    this.rewardPointsCurrentId = 1;
    this.rewardPointsHistoryCurrentId = 1;
    this.achievementsCurrentId = 1;
    this.userAchievementsCurrentId = 1;
    this.rewardsCurrentId = 1;
    this.rewardRedemptionsCurrentId = 1;
    this.leaderboardsCurrentId = 1;
    this.leaderboardResultsCurrentId = 1;
  }
  
  // Users
  async getUser(id: number): Promise<User | undefined> {
    return this.users.get(id);
  }
  
  async getUsers(): Promise<User[]> {
    return Array.from(this.users.values());
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(user => user.username === username);
  }
  
  async createUser(insertUser: InsertUser): Promise<User> {
    const id = this.userCurrentId++;
    const user: User = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  
  async updateUser(id: number, userData: Partial<User>): Promise<User | undefined> {
    const user = this.users.get(id);
    if (!user) return undefined;
    
    const updatedUser = { ...user, ...userData };
    this.users.set(id, updatedUser);
    return updatedUser;
  }
  
  async deleteUser(id: number): Promise<boolean> {
    return this.users.delete(id);
  }
  
  // Branches
  async getBranch(id: number): Promise<Branch | undefined> {
    return this.branches.get(id);
  }
  
  async getBranches(): Promise<Branch[]> {
    return Array.from(this.branches.values());
  }
  
  async createBranch(insertBranch: InsertBranch): Promise<Branch> {
    const id = this.branchCurrentId++;
    const branch: Branch = { ...insertBranch, id };
    this.branches.set(id, branch);
    return branch;
  }
  
  async updateBranch(id: number, branchData: Partial<Branch>): Promise<Branch | undefined> {
    const branch = this.branches.get(id);
    if (!branch) return undefined;
    
    const updatedBranch = { ...branch, ...branchData };
    this.branches.set(id, updatedBranch);
    return updatedBranch;
  }
  
  // Monthly Targets
  async getMonthlyTarget(id: number): Promise<MonthlyTarget | undefined> {
    return this.monthlyTargets.get(id);
  }
  
  async getMonthlyTargets(): Promise<MonthlyTarget[]> {
    return Array.from(this.monthlyTargets.values());
  }
  
  async getMonthlyTargetByBranchAndDate(branchId: number, month: number, year: number): Promise<MonthlyTarget | undefined> {
    return Array.from(this.monthlyTargets.values()).find(
      target => target.branchId === branchId && target.month === month && target.year === year
    );
  }
  
  async createMonthlyTarget(insertTarget: InsertMonthlyTarget): Promise<MonthlyTarget> {
    const id = this.targetCurrentId++;
    const target: MonthlyTarget = { ...insertTarget, id };
    this.monthlyTargets.set(id, target);
    return target;
  }
  
  // Daily Sales
  async getDailySales(): Promise<DailySales[]> {
    return Array.from(this.dailySales.values());
  }
  
  async getDailySalesById(id: number): Promise<DailySales | undefined> {
    return this.dailySales.get(id);
  }
  
  async getDailySalesByBranchAndDate(branchId: number, date: string): Promise<DailySales[]> {
    return Array.from(this.dailySales.values()).filter(sale => {
      // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId = 0ØŒ ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡ ÙƒÙ€ "ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹" ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù†Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯
      if (branchId === 0) {
        return sale.date === date;
      }
      
      // Ø®Ù„Ø§Ù Ø°Ù„ÙƒØŒ Ù†Ù‚ÙˆÙ… Ø¨Ø§Ù„ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
      return sale.branchId === branchId && sale.date === date;
    });
  }
  
  async getDailySalesByBranchAndDateRange(branchId: number, startDate: string, endDate: string): Promise<DailySales[]> {
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    return Array.from(this.dailySales.values()).filter(sale => {
      const saleDate = new Date(sale.date);
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId = 0ØŒ ÙŠØªÙ… Ø§Ø¹ØªØ¨Ø§Ø±Ù‡ ÙƒÙ€ "ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹" ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ Ù†Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠ
      if (branchId === 0) {
        return saleDate >= start && saleDate <= end;
      }
      
      // Ø®Ù„Ø§Ù Ø°Ù„ÙƒØŒ Ù†Ù‚ÙˆÙ… Ø¨Ø§Ù„ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
      return sale.branchId === branchId && saleDate >= start && saleDate <= end;
    });
  }
  
  async getDailySalesByCashierAndDate(cashierId: number, date: string): Promise<DailySales | undefined> {
    return Array.from(this.dailySales.values()).find(
      sale => sale.cashierId === cashierId && sale.date === date
    );
  }
  
  async createDailySales(insertSales: InsertDailySales): Promise<DailySales> {
    const id = this.salesCurrentId++;
    const sales: DailySales = { ...insertSales, id };
    this.dailySales.set(id, sales);
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    await this.updateTargetWithSales(sales);
    
    return sales;
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
   * ÙŠØªÙ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ù…Ø¨ÙŠØ¹Ø§Øª Ø¬Ø¯ÙŠØ¯
   */
  private async updateTargetWithSales(sales: DailySales): Promise<void> {
    try {
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø´Ù‡Ø± ÙˆØ§Ù„Ø³Ù†Ø© Ù…Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
      const saleDate = new Date(sales.date);
      const month = saleDate.getMonth() + 1; // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ù‡Ø± Ù…Ù† 0-11 Ø¥Ù„Ù‰ 1-12
      const year = saleDate.getFullYear();
      
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„ÙØ±Ø¹ ÙˆØ§Ù„Ø´Ù‡Ø± ÙˆØ§Ù„Ø³Ù†Ø©
      const target = await this.getMonthlyTargetByBranchAndDate(sales.branchId, month, year);
      
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ù‡Ø¯Ù Ù…Ø·Ø§Ø¨Ù‚ØŒ Ù†Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø¯Ø§Ù„Ø©
      if (!target) return;
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„ÙØ±Ø¹ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±
      const startOfMonthDate = new Date(year, month - 1, 1);
      const endOfMonthDate = new Date(year, month, 0);
      
      const startDate = format(startOfMonthDate, 'yyyy-MM-dd');
      const endDate = format(endOfMonthDate, 'yyyy-MM-dd');
      
      const monthlySales = await this.getDailySalesByBranchAndDateRange(
        sales.branchId,
        startDate,
        endDate
      );
      
      // ØªØ¬Ù…ÙŠØ¹ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±
      const totalMonthlySales = monthlySales.reduce(
        (total, sale) => total + sale.totalSales,
        0
      );
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«
      await this.createActivity({
        userId: sales.cashierId,
        action: "target_update_from_sales",
        details: { 
          branchId: sales.branchId, 
          month, 
          year, 
          saleAmount: sales.totalSales,
          totalMonthlySales,
          targetAmount: target.targetAmount 
        },
        branchId: sales.branchId,
        timestamp: new Date()
      });
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¥Ø°Ø§ ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ù†Ø³Ø¨Ø© Ù…Ù‡Ù…Ø© Ù…Ù† Ø§Ù„Ù‡Ø¯Ù
      const achievementPercentage = (totalMonthlySales / target.targetAmount) * 100;
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¹Ù†Ø¯ ØªØ­Ù‚ÙŠÙ‚ Ù†Ø³Ø¨ Ù…Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ù‡Ø¯Ù
      const milestones = [50, 75, 90, 100];
      for (const milestone of milestones) {
        // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        if (achievementPercentage >= milestone && achievementPercentage - (sales.totalSales / target.targetAmount * 100) < milestone) {
          await this.createNotification({
            userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
            title: `ØªÙ… ØªØ­Ù‚ÙŠÙ‚ ${milestone}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ`,
            message: `ÙØ±Ø¹ #${sales.branchId} Ø­Ù‚Ù‚ ${achievementPercentage.toFixed(1)}% Ù…Ù† Ù‡Ø¯Ù Ø´Ù‡Ø± ${month}/${year}`,
            type: milestone >= 100 ? "success" : "info",
            timestamp: new Date(),
            link: "/targets"
          });
          break; // Ø§Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø­Ù„Ù‚Ø© Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ù…Ù„Ø§Ø¦Ù…
        }
      }
    } catch (error) {
      console.error("Error updating target with sales:", error);
    }
  }
  
  // Activities
  async getActivities(limit?: number): Promise<Activity[]> {
    let activities = Array.from(this.activities.values()).sort((a, b) => {
      const dateA = new Date(a.timestamp);
      const dateB = new Date(b.timestamp);
      return dateB.getTime() - dateA.getTime();
    });
    
    if (limit) {
      activities = activities.slice(0, limit);
    }
    
    return activities;
  }
  
  async getActivitiesByBranch(branchId: number, limit?: number): Promise<Activity[]> {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId = 0ØŒ Ù‚Ù… Ø¨Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹ (Ø¨Ø¯ÙˆÙ† ÙÙ„ØªØ±Ø©)
    let activities = Array.from(this.activities.values());
    
    // ÙÙ„ØªØ±Ø© Ø§Ù„Ø£Ù†Ø´Ø·Ø© Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙØ±Ø¹ Ù…Ø­Ø¯Ø¯ (ØºÙŠØ± ØµÙØ±)
    if (branchId !== 0) {
      activities = activities.filter(activity => activity.branchId === branchId);
    }
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ® ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    activities = activities.sort((a, b) => {
        const dateA = new Date(a.timestamp);
        const dateB = new Date(b.timestamp);
        return dateB.getTime() - dateA.getTime();
      });
    
    if (limit) {
      activities = activities.slice(0, limit);
    }
    
    return activities;
  }
  
  async createActivity(insertActivity: InsertActivity): Promise<Activity> {
    const id = this.activityCurrentId++;
    const activity: Activity = { ...insertActivity, id };
    this.activities.set(id, activity);
    return activity;
  }
  
  // Notifications
  async getNotifications(limit?: number): Promise<Notification[]> {
    let notifications = Array.from(this.notifications.values()).sort((a, b) => {
      const dateA = new Date(a.timestamp);
      const dateB = new Date(b.timestamp);
      return dateB.getTime() - dateA.getTime();
    });
    
    if (limit) {
      notifications = notifications.slice(0, limit);
    }
    
    return notifications;
  }
  
  async getNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]> {
    let notifications;
    
    if (userId) {
      notifications = Array.from(this.notifications.values())
        .filter(notification => notification.userId === userId || notification.userId === null)
        .sort((a, b) => {
          const dateA = new Date(a.timestamp);
          const dateB = new Date(b.timestamp);
          return dateB.getTime() - dateA.getTime();
        });
    } else {
      notifications = Array.from(this.notifications.values()).sort((a, b) => {
        const dateA = new Date(a.timestamp);
        const dateB = new Date(b.timestamp);
        return dateB.getTime() - dateA.getTime();
      });
    }
    
    if (limit) {
      notifications = notifications.slice(0, limit);
    }
    
    return notifications;
  }
  
  async getUnreadNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]> {
    let notifications;
    
    if (userId) {
      notifications = Array.from(this.notifications.values())
        .filter(notification => (notification.userId === userId || notification.userId === null) && notification.isRead === false)
        .sort((a, b) => {
          const dateA = new Date(a.timestamp);
          const dateB = new Date(b.timestamp);
          return dateB.getTime() - dateA.getTime();
        });
    } else {
      notifications = Array.from(this.notifications.values())
        .filter(notification => notification.isRead === false)
        .sort((a, b) => {
          const dateA = new Date(a.timestamp);
          const dateB = new Date(b.timestamp);
          return dateB.getTime() - dateA.getTime();
        });
    }
    
    if (limit) {
      notifications = notifications.slice(0, limit);
    }
    
    return notifications;
  }
  
  async markNotificationAsRead(id: number): Promise<Notification | undefined> {
    const notification = this.notifications.get(id);
    if (!notification) return undefined;
    
    const updatedNotification = { ...notification, isRead: true };
    this.notifications.set(id, updatedNotification);
    return updatedNotification;
  }
  
  async createNotification(insertNotification: InsertNotification): Promise<Notification> {
    const id = this.notificationCurrentId++;
    const notification: Notification = { ...insertNotification, id, isRead: false };
    this.notifications.set(id, notification);
    return notification;
  }
  
  // Dashboard Stats
  async getDashboardStats(branchId: number, date: Date): Promise<DashboardStats> {
    const formattedDate = format(date, 'yyyy-MM-dd');
    const currentMonth = date.getMonth() + 1;
    const currentYear = date.getFullYear();
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…
    const dailySalesData = await this.getDailySalesByBranchAndDate(branchId, formattedDate);
    const dailySalesTotal = dailySalesData.reduce((sum, sale) => sum + sale.totalSales, 0);
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId = 0 (ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹)ØŒ Ù†Ø­Ø³Ø¨ Ù…Ø¬Ù…ÙˆØ¹ Ø£Ù‡Ø¯Ø§Ù ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹
    let monthlyTarget = null;
    let dailyTarget = 0;
    
    if (branchId === 0) {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹
      const branches = await this.getBranches();
      
      // Ø­Ø³Ø§Ø¨ Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø´Ù‡Ø±ÙŠØ© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹
      let totalMonthlyTargetAmount = 0;
      
      for (const branch of branches) {
        const branchTarget = await this.getMonthlyTargetByBranchAndDate(branch.id, currentMonth, currentYear);
        if (branchTarget) {
          totalMonthlyTargetAmount += branchTarget.targetAmount;
        }
      }
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø¯Ù Ø´Ù‡Ø±ÙŠ ØªØ¬Ù…ÙŠØ¹ÙŠ "Ø§ÙØªØ±Ø§Ø¶ÙŠ"
      monthlyTarget = { targetAmount: totalMonthlyTargetAmount };
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ
      const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
      dailyTarget = totalMonthlyTargetAmount / daysInMonth;
    } else {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ù„Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
      monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, currentMonth, currentYear);
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ Ø§Ø³ØªÙ†Ø§Ø¯Ø§Ù‹ Ø¥Ù„Ù‰ Ù†Ù…Ø· Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø£Ùˆ Ø§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ø¨Ø³ÙŠØ·Ø©
      if (monthlyTarget) {
        const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
        dailyTarget = monthlyTarget.targetAmount / daysInMonth;
      }
    }
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠØ© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†
    const startOfMonthDate = new Date(date.getFullYear(), date.getMonth(), 1);
    const endOfMonthDate = new Date(date.getFullYear(), date.getMonth() + 1, 0);
    
    const startDateFormatted = format(startOfMonthDate, 'yyyy-MM-dd');
    const endDateFormatted = format(endOfMonthDate, 'yyyy-MM-dd');
    
    const monthlySalesData = await this.getDailySalesByBranchAndDateRange(branchId, startDateFormatted, endDateFormatted);
    const monthlySalesTotal = monthlySalesData.reduce((sum, sale) => sum + sale.totalSales, 0);
    
    // Ø­Ø³Ø§Ø¨ ØªÙˆØ²ÙŠØ¹ ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ø¯ÙØ¹
    const totalCash = dailySalesData.reduce((sum, sale) => sum + sale.totalCashSales, 0);
    const totalNetwork = dailySalesData.reduce((sum, sale) => {
      if (typeof sale.totalNetworkSales !== 'undefined') {
        return sum + sale.totalNetworkSales;
      }
      return sum;
    }, 0);
    
    const total = totalCash + totalNetwork;
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø© ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    const totalTransactions = dailySalesData.reduce((sum, sale) => sum + sale.totalTransactions, 0);
    const averageTicket = totalTransactions > 0 ? dailySalesTotal / totalTransactions : 0;
    
    return {
      dailySales: dailySalesTotal,
      dailyTarget,
      dailyTargetPercentage: dailyTarget > 0 ? (dailySalesTotal / dailyTarget) * 100 : 0,
      monthlyTargetAmount: monthlyTarget?.targetAmount || 0,
      monthlySalesAmount: monthlySalesTotal,
      monthlyTargetPercentage: monthlyTarget?.targetAmount ? (monthlySalesTotal / monthlyTarget.targetAmount) * 100 : 0,
      averageTicket,
      totalTransactions,
      paymentMethodsBreakdown: {
        cash: { 
          amount: totalCash, 
          percentage: total > 0 ? (totalCash / total) * 100 : 0 
        },
        network: { 
          amount: totalNetwork, 
          percentage: total > 0 ? (totalNetwork / total) * 100 : 0 
        }
      }
    };
  }
  
  async getBranchTargetAchievement(month: number, year: number, specificBranchId?: number): Promise<any[]> {
    // ØªØ­Ø¯ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ÙØ±ÙˆØ¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ù„Ù‡Ø§
    let branchesList: Branch[] = [];
    
    if (specificBranchId !== undefined && specificBranchId !== 0) {
      // Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø±Ù‚Ù… ÙØ±Ø¹ Ù…Ø­Ø¯Ø¯ (ÙˆÙ„ÙŠØ³ ØµÙØ±)
      const branch = await this.getBranch(specificBranchId);
      if (branch) {
        branchesList = [branch];
      }
    } else {
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙØ±Ø¹ØŒ Ø£Ùˆ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‚ÙŠÙ…Ø© ØµÙØ± (ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹)
      branchesList = await this.getBranches();
    }
    
    const results = [];
    
    // ØªØ¬Ù‡ÙŠØ² Ø¹Ø±Ø¶ ØªØ¬Ù…ÙŠØ¹ÙŠ Ù„Ù„ÙØ±ÙˆØ¹ Ø¥Ø°Ø§ ÙƒØ§Ù† specificBranchId = 0
    if (specificBranchId === 0) {
      // Ù‚ÙŠÙ… ØªØ¬Ù…ÙŠØ¹ÙŠØ© Ù„ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹
      let totalTargetAmount = 0;
      let totalAchievedAmount = 0;
      
      // Ø­Ø³Ø§Ø¨ Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙˆØ§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª Ù„ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹
      for (const branch of branchesList) {
        const target = await this.getMonthlyTargetByBranchAndDate(branch.id, month, year);
        
        if (target) {
          const startDateStr = format(new Date(year, month - 1, 1), 'yyyy-MM-dd');
          const endDateStr = format(new Date(year, month, 0), 'yyyy-MM-dd');
          
          const sales = await this.getDailySalesByBranchAndDateRange(branch.id, startDateStr, endDateStr);
          const branchTotalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
          
          totalTargetAmount += target.targetAmount;
          totalAchievedAmount += branchTotalSales;
        }
      }
      
      // Ø­Ø³Ø§Ø¨ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©
      const totalAchievementPercentage = totalTargetAmount > 0 ? (totalAchievedAmount / totalTargetAmount) * 100 : 0;
      
      // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
      let overallStatus = "ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†"; // Needs improvement
      if (totalAchievementPercentage >= 95) {
        overallStatus = "Ù…Ù…ØªØ§Ø²"; // Excellent
      } else if (totalAchievementPercentage >= 85) {
        overallStatus = "Ø¬ÙŠØ¯ Ø¬Ø¯Ù‹Ø§"; // Very good
      } else if (totalAchievementPercentage >= 75) {
        overallStatus = "Ø¬ÙŠØ¯"; // Good
      }
      
      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ¬Ù…ÙŠØ¹ÙŠØ©
      results.push({
        branchId: 0,
        branchName: "ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹",
        target: totalTargetAmount,
        achieved: totalAchievedAmount,
        percentage: totalAchievementPercentage,
        status: overallStatus
      });
    }
    
    // Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ ÙØ±Ø¹ Ø¹Ù„Ù‰ Ø­Ø¯Ø©
    for (const branch of branchesList) {
      const target = await this.getMonthlyTargetByBranchAndDate(branch.id, month, year);
      
      if (target) {
        const startDateStr = format(new Date(year, month - 1, 1), 'yyyy-MM-dd');
        const endDateStr = format(new Date(year, month, 0), 'yyyy-MM-dd');
        
        const sales = await this.getDailySalesByBranchAndDateRange(branch.id, startDateStr, endDateStr);
        const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
        const achievementPercentage = (totalSales / target.targetAmount) * 100;
        
        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
        let status = "ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†"; // Needs improvement
        if (achievementPercentage >= 95) {
          status = "Ù…Ù…ØªØ§Ø²"; // Excellent
        } else if (achievementPercentage >= 85) {
          status = "Ø¬ÙŠØ¯ Ø¬Ø¯Ù‹Ø§"; // Very good
        } else if (achievementPercentage >= 75) {
          status = "Ø¬ÙŠØ¯"; // Good
        }
        
        // Ù†Ø¶ÙŠÙ Ù†ØªÙŠØ¬Ø© Ø§Ù„ÙØ±Ø¹ ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ù†Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹ Ù…Ù†ÙØµÙ„ÙŠÙ† Ø£Ùˆ Ø¥Ø°Ø§ ÙƒÙ†Ø§ Ù†Ø¹Ø±Ø¶ ÙØ±Ø¹ Ù…Ø­Ø¯Ø¯
        if (specificBranchId !== 0) {
          results.push({
            branchId: branch.id,
            branchName: branch.name,
            target: target.targetAmount,
            achieved: totalSales,
            percentage: achievementPercentage,
            status
          });
        }
      }
    }
    
    return results;
  }
  
  // Consolidated Daily Sales
  async getConsolidatedDailySales(): Promise<ConsolidatedDailySales[]> {
    return Array.from(this.consolidatedDailySales.values());
  }
  
  async getConsolidatedDailySalesByBranch(branchId: number): Promise<ConsolidatedDailySales[]> {
    // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId ÙŠØ³Ø§ÙˆÙŠ 0ØŒ ÙÙ‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹ (Ø¨Ø¯ÙˆÙ† ØªØµÙÙŠØ©)
    const consolidatedSales = Array.from(this.consolidatedDailySales.values());
    
    // Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙØ±Ø¹ Ù…Ø¹ÙŠÙ† (ØºÙŠØ± Ø§Ù„ØµÙØ±)ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    const filteredSales = branchId === 0 
      ? consolidatedSales 
      : consolidatedSales.filter(sale => sale.branchId === branchId);
      
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ® ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§
    return filteredSales.sort((a, b) => {
        const dateA = new Date(a.date);
        const dateB = new Date(b.date);
        return dateB.getTime() - dateA.getTime(); // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
      });
  }
  
  async getConsolidatedDailySalesByDate(date: string): Promise<ConsolidatedDailySales[]> {
    return Array.from(this.consolidatedDailySales.values())
      .filter(sale => sale.date === date)
      .sort((a, b) => a.branchId - b.branchId); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹
  }
  
  async getConsolidatedDailySalesById(id: number): Promise<ConsolidatedDailySales | undefined> {
    return this.consolidatedDailySales.get(id);
  }
  
  async createConsolidatedDailySales(insertSales: InsertConsolidatedDailySales): Promise<ConsolidatedDailySales> {
    const id = this.consolidatedSalesCurrentId++;
    const consolidatedSales: ConsolidatedDailySales = { ...insertSales, id };
    this.consolidatedDailySales.set(id, consolidatedSales);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø¥Ù†Ø´Ø§Ø¡ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø©
    await this.createActivity({
      userId: insertSales.createdBy || null,
      action: "create_consolidated_sales",
      details: { 
        branchId: insertSales.branchId, 
        date: insertSales.date,
        totalAmount: insertSales.totalSales
      },
      branchId: insertSales.branchId,
      timestamp: new Date()
    });
    
    return consolidatedSales;
  }
  
  async closeConsolidatedDailySales(id: number, userId: number): Promise<ConsolidatedDailySales | undefined> {
    const consolidatedSales = this.consolidatedDailySales.get(id);
    if (!consolidatedSales) return undefined;
    
    const updatedSales = { 
      ...consolidatedSales,
      status: "closed",
      closedBy: userId,
      closedAt: new Date()
    };
    
    this.consolidatedDailySales.set(id, updatedSales);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    await this.createActivity({
      userId,
      action: "close_consolidated_sales",
      details: { 
        branchId: consolidatedSales.branchId, 
        date: consolidatedSales.date,
        totalAmount: consolidatedSales.totalSales
      },
      branchId: consolidatedSales.branchId,
      timestamp: new Date()
    });
    
    return updatedSales;
  }
  
  // Daily Sales Operations
  async checkExistingDailySales(cashierId: number, date: string): Promise<boolean> {
    const existingSales = Array.from(this.dailySales.values()).find(
      sale => sale.cashierId === cashierId && sale.date === date
    );
    
    return existingSales !== undefined;
  }
  
  async updateDailySalesStatus(id: number, status: string, consolidatedId?: number): Promise<DailySales | undefined> {
    const sales = this.dailySales.get(id);
    if (!sales) return undefined;
    
    const updatedSales = { 
      ...sales, 
      status,
      consolidatedId: consolidatedId || sales.consolidatedId
    };
    
    this.dailySales.set(id, updatedSales);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    await this.createActivity({
      userId: sales.cashierId,
      action: "update_daily_sales_status",
      details: { 
        branchId: sales.branchId, 
        date: sales.date,
        oldStatus: sales.status,
        newStatus: status
      },
      branchId: sales.branchId,
      timestamp: new Date()
    });
    
    return updatedSales;
  }
  
  async consolidateDailySales(branchId: number, date: string, userId: number): Promise<ConsolidatedDailySales | undefined> {
    // 1. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙŠÙˆÙ…ÙŠØ§Øª Ù„Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø­Ø¯Ø¯
    const dailySales = Array.from(this.dailySales.values()).filter(
      sale => sale.branchId === branchId && sale.date === date
    );
    
    if (dailySales.length === 0) {
      return undefined;
    }
    
    // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø© Ø³Ø§Ø¨Ù‚Ø© Ù„Ù†ÙØ³ Ø§Ù„ÙØ±Ø¹ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
    const existingConsolidated = Array.from(this.consolidatedDailySales.values()).find(
      sale => sale.branchId === branchId && sale.date === date
    );
    
    if (existingConsolidated) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø© Ø³Ø§Ø¨Ù‚Ø©ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ«Ù‡Ø§
      return this.updateConsolidatedSales(existingConsolidated, dailySales, userId);
    }
    
    // 3. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ§Øª
    let totalCashSales = 0;
    let totalNetworkSales = 0;
    let totalSales = 0;
    let totalTransactions = 0;
    let totalDiscrepancy = 0;
    
    dailySales.forEach(sale => {
      totalCashSales += sale.totalCashSales || 0;
      totalNetworkSales += sale.totalNetworkSales || 0;
      totalSales += sale.totalSales || 0;
      totalTransactions += sale.totalTransactions || 0;
      if (sale.discrepancy) {
        totalDiscrepancy += sale.discrepancy;
      }
    });
    
    // 4. Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø©
    const averageTicket = totalTransactions > 0 ? totalSales / totalTransactions : 0;
    
    // 5. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    const consolidatedSale = await this.createConsolidatedDailySales({
      branchId,
      date,
      totalCashSales,
      totalNetworkSales,
      totalSales,
      totalTransactions,
      averageTicket,
      totalDiscrepancy,
      status: "open",
      createdBy: userId,
      createdAt: new Date()
    });
    
    // 6. ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ§Øª Ø§Ù„ÙØ±Ø¯ÙŠØ© Ø¨Ø£Ù†Ù‡Ø§ Ù…Ø±Ø­Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    for (const sale of dailySales) {
      await this.updateDailySalesStatus(sale.id, "transferred", consolidatedSale.id);
    }
    
    return consolidatedSale;
  }
  
  // Ø·Ø±ÙŠÙ‚Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­Ø¯ÙŠØ« ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©
  private async updateConsolidatedSales(
    existingConsolidated: ConsolidatedDailySales, 
    dailySales: DailySales[], 
    userId: number
  ): Promise<ConsolidatedDailySales> {
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ§Øª
    let totalCashSales = 0;
    let totalNetworkSales = 0;
    let totalSales = 0;
    let totalTransactions = 0;
    let totalDiscrepancy = 0;
    
    dailySales.forEach(sale => {
      totalCashSales += sale.totalCashSales || 0;
      totalNetworkSales += sale.totalNetworkSales || 0;
      totalSales += sale.totalSales || 0;
      totalTransactions += sale.totalTransactions || 0;
      if (sale.discrepancy) {
        totalDiscrepancy += sale.discrepancy;
      }
    });
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø©
    const averageTicket = totalTransactions > 0 ? totalSales / totalTransactions : 0;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    const updatedSales = { 
      ...existingConsolidated,
      totalCashSales,
      totalNetworkSales,
      totalSales,
      totalTransactions,
      averageTicket,
      totalDiscrepancy
    };
    
    this.consolidatedDailySales.set(existingConsolidated.id, updatedSales);
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ÙŠÙˆÙ…ÙŠØ§Øª Ø§Ù„ÙØ±Ø¯ÙŠØ© Ù„ØªØ´ÙŠØ± Ø¥Ù„Ù‰ Ø£Ù†Ù‡Ø§ Ù…Ø±Ø­Ù„Ø©
    for (const sale of dailySales) {
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ© ØºÙŠØ± Ù…Ø±Ø­Ù„Ø© Ø³Ø§Ø¨Ù‚Ù‹Ø§ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªØ±Ø­ÙŠÙ„Ù‡Ø§
      if (sale.status !== "transferred" || !sale.consolidatedId) {
        await this.updateDailySalesStatus(sale.id, "transferred", existingConsolidated.id);
      }
    }
    
    return updatedSales;
  }
  
  // ØªÙ… Ù†Ù‚Ù„ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ø¥Ù„Ù‰ ØªÙ†ÙÙŠØ° Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ø§Ù†Ø¸Ø± Ø£Ø¯Ù†Ø§Ù‡
  
  async getSalesAnalytics(branchId: number, period: string): Promise<any> {
    const today = new Date();
    let startDate: Date;
    let endDate = today;
    let pattern = 'dd/MM';
    
    switch (period) {
      case 'weekly':
        startDate = startOfWeek(today, { weekStartsOn: 6 }); // ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…Ù† ÙŠÙˆÙ… Ø§Ù„Ø³Ø¨Øª
        endDate = endOfWeek(today, { weekStartsOn: 6 });
        pattern = 'EEE'; // Ø§Ø³Ù… Ø§Ù„ÙŠÙˆÙ… (Ø§Ù„Ø³Ø¨ØªØŒ Ø§Ù„Ø£Ø­Ø¯ØŒ Ø¥Ù„Ø®)
        break;
      case 'monthly':
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        pattern = 'dd/MM';
        break;
      case 'yearly':
        startDate = new Date(today.getFullYear(), 0, 1);
        endDate = new Date(today.getFullYear(), 11, 31);
        pattern = 'MMM'; // Ø§Ø³Ù… Ø§Ù„Ø´Ù‡Ø± (ÙŠÙ†Ø§ÙŠØ±ØŒ ÙØ¨Ø±Ø§ÙŠØ±ØŒ Ø¥Ù„Ø®)
        break;
      default:
        startDate = subDays(today, 7);
        pattern = 'dd/MM';
    }
    
    const startDateStr = format(startDate, 'yyyy-MM-dd');
    const endDateStr = format(endDate, 'yyyy-MM-dd');
    
    const salesData = await this.getDailySalesByBranchAndDateRange(branchId, startDateStr, endDateStr);
    
    // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const salesByDate = new Map();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚
    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = format(currentDate, 'yyyy-MM-dd');
      const formattedDate = format(currentDate, pattern, { locale: ar });
      
      salesByDate.set(dateKey, {
        date: formattedDate,
        cashSales: 0,
        networkSales: 0,
        totalSales: 0,
        target: 0
      });
      
      currentDate = addDays(currentDate, 1);
    }
    
    // Ù…Ù„Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ¹Ù„ÙŠØ©
    for (const sale of salesData) {
      const dateKey = format(new Date(sale.date), 'yyyy-MM-dd');
      
      if (salesByDate.has(dateKey)) {
        const currentData = salesByDate.get(dateKey);
        
        currentData.cashSales += sale.totalCashSales;
        
        if (typeof sale.totalNetworkSales !== 'undefined') {
          currentData.networkSales += sale.totalNetworkSales;
        }
        
        currentData.totalSales += sale.totalSales;
      }
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ø¯Ù
    const month = today.getMonth() + 1;
    const year = today.getFullYear();
    const monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, month, year);
    
    if (monthlyTarget) {
      const daysInMonth = new Date(year, month, 0).getDate();
      const dailyTarget = monthlyTarget.targetAmount / daysInMonth;
      
      for (const [dateKey, data] of salesByDate.entries()) {
        data.target = dailyTarget;
      }
    }
    
    return Array.from(salesByDate.values());
  }
  
  // ==== ÙˆØ¸Ø§Ø¦Ù Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ² ====
  
  // Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getUserRewardPoints(userId: number): Promise<RewardPoints | undefined> {
    return Array.from(this.rewardPoints.values()).find(points => points.userId === userId);
  }
  
  async updateUserRewardPoints(userId: number, points: number): Promise<RewardPoints | undefined> {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    let userPoints = await this.getUserRewardPoints(userId);
    
    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ù†Ù‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§
    if (!userPoints) {
      const id = this.rewardPointsCurrentId++;
      userPoints = {
        id,
        userId,
        points: 0,
        availablePoints: 0,
        totalEarnedPoints: 0,
        lastUpdated: new Date()
      };
      this.rewardPoints.set(id, userPoints);
    }
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ù‚Ø§Ø·
    const updatedPoints = {
      ...userPoints,
      points: userPoints.points + points,
      availablePoints: userPoints.availablePoints + (points > 0 ? points : 0), // Ù†Ø¶ÙŠÙ ÙÙ‚Ø· Ù„Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ØªØ§Ø­Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¥Ø¶Ø§ÙØ© ÙˆÙ„ÙŠØ³Øª Ø®ØµÙ…
      totalEarnedPoints: userPoints.totalEarnedPoints + (points > 0 ? points : 0), // Ù†Ø¶ÙŠÙ ÙÙ‚Ø· Ù„Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¥Ø¶Ø§ÙØ©
      lastUpdated: new Date()
    };
    
    this.rewardPoints.set(updatedPoints.id, updatedPoints);
    return updatedPoints;
  }
  
  async addRewardPointsHistory(history: InsertRewardPointsHistory): Promise<RewardPointsHistory> {
    const id = this.rewardPointsHistoryCurrentId++;
    const newHistory: RewardPointsHistory = { ...history, id };
    this.rewardPointsHistory.set(id, newHistory);
    
    // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await this.updateUserRewardPoints(history.userId, history.points);
    
    return newHistory;
  }
  
  async getRewardPointsHistory(userId: number, limit?: number): Promise<RewardPointsHistory[]> {
    let history = Array.from(this.rewardPointsHistory.values())
      .filter(h => h.userId === userId)
      .sort((a, b) => {
        const dateA = new Date(a.timestamp);
        const dateB = new Date(b.timestamp);
        return dateB.getTime() - dateA.getTime();
      });
    
    if (limit) {
      history = history.slice(0, limit);
    }
    
    return history;
  }
  
  async getRewardPointsHistoryByType(userId: number, type: string): Promise<RewardPointsHistory[]> {
    return Array.from(this.rewardPointsHistory.values())
      .filter(h => h.userId === userId && h.type === type)
      .sort((a, b) => {
        const dateA = new Date(a.timestamp);
        const dateB = new Date(b.timestamp);
        return dateB.getTime() - dateA.getTime();
      });
  }
  
  // Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª
  async getAllAchievements(): Promise<Achievement[]> {
    return Array.from(this.achievements.values())
      .filter(a => a.isActive)
      .sort((a, b) => a.name.localeCompare(b.name));
  }
  
  async getAchievement(id: number): Promise<Achievement | undefined> {
    return this.achievements.get(id);
  }
  
  async getAchievementsByCategory(category: string): Promise<Achievement[]> {
    return Array.from(this.achievements.values())
      .filter(a => a.category === category && a.isActive)
      .sort((a, b) => a.name.localeCompare(b.name));
  }
  
  async createAchievement(achievement: InsertAchievement): Promise<Achievement> {
    const id = this.achievementsCurrentId++;
    const newAchievement: Achievement = { ...achievement, id };
    this.achievements.set(id, newAchievement);
    return newAchievement;
  }
  
  async updateAchievement(id: number, achievement: Partial<Achievement>): Promise<Achievement | undefined> {
    const existingAchievement = this.achievements.get(id);
    if (!existingAchievement) return undefined;
    
    const updatedAchievement = { ...existingAchievement, ...achievement };
    this.achievements.set(id, updatedAchievement);
    return updatedAchievement;
  }
  
  // Ø¥Ù†Ø¬Ø§Ø²Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  async getUserAchievements(userId: number): Promise<UserAchievement[]> {
    return Array.from(this.userAchievements.values())
      .filter(ua => ua.userId === userId)
      .sort((a, b) => {
        if (a.isCompleted === b.isCompleted) {
          // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙƒÙ„Ø§Ù‡Ù…Ø§ Ù…ÙƒØªÙ…Ù„ Ø£Ùˆ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„ØŒ Ù†Ø±ØªØ¨ Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
          const dateA = a.completedAt ? new Date(a.completedAt) : new Date(a.awardedAt);
          const dateB = b.completedAt ? new Date(b.completedAt) : new Date(b.awardedAt);
          return dateB.getTime() - dateA.getTime();
        }
        // ÙˆØ¶Ø¹ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹
        return a.isCompleted ? -1 : 1;
      });
  }
  
  async assignAchievementToUser(userAchievement: InsertUserAchievement): Promise<UserAchievement> {
    const id = this.userAchievementsCurrentId++;
    const newUserAchievement: UserAchievement = { 
      ...userAchievement, 
      id,
      awardedAt: new Date(),
      isCompleted: false
    };
    this.userAchievements.set(id, newUserAchievement);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const achievement = await this.getAchievement(userAchievement.achievementId);
    if (achievement) {
      await this.createNotification({
        userId: userAchievement.userId,
        title: "Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯ Ù…ØªØ§Ø­!",
        message: `ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯: ${achievement.name}. Ø§ÙƒØªØ´Ù ÙƒÙŠÙÙŠØ© ØªØ­Ù‚ÙŠÙ‚Ù‡!`,
        type: "info",
        timestamp: new Date(),
        link: "/achievements"
      });
    }
    
    return newUserAchievement;
  }
  
  async updateUserAchievementProgress(userId: number, achievementId: number, progress: number): Promise<UserAchievement | undefined> {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const userAchievement = Array.from(this.userAchievements.values())
      .find(ua => ua.userId === userId && ua.achievementId === achievementId);
    
    if (!userAchievement) return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
    const newProgress = Math.min(Math.max(progress, 0), 100); // Ø¶Ù…Ø§Ù† Ø£Ù† Ø§Ù„ØªÙ‚Ø¯Ù… Ø¨ÙŠÙ† 0 Ùˆ 100
    const updatedUserAchievement = { ...userAchievement, progress: newProgress };
    
    // Ø¥Ø°Ø§ ÙˆØµÙ„ Ø§Ù„ØªÙ‚Ø¯Ù… Ø¥Ù„Ù‰ 100%ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ù…ÙƒØªÙ…Ù„Ø§Ù‹
    if (newProgress >= 100 && !userAchievement.isCompleted) {
      updatedUserAchievement.isCompleted = true;
      updatedUserAchievement.completedAt = new Date();
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø·
      const achievement = await this.getAchievement(achievementId);
      if (achievement) {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await this.addRewardPointsHistory({
          userId,
          points: achievement.pointsValue,
          type: "earned",
          reason: `ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø¥Ù†Ø¬Ø§Ø²: ${achievement.name}`,
          relatedEntityType: "achievement",
          relatedEntityId: achievementId,
          date: new Date(),
          timestamp: new Date(),
          status: "active",
          branchId: null
        });
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¨ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
        await this.createNotification({
          userId,
          title: "ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø¥Ù†Ø¬Ø§Ø²",
          message: `Ù„Ù‚Ø¯ Ø­Ù‚Ù‚Øª Ø¥Ù†Ø¬Ø§Ø² "${achievement.name}" ÙˆÙƒØ³Ø¨Øª ${achievement.pointsValue} Ù†Ù‚Ø·Ø©!`,
          type: "success",
          timestamp: new Date(),
          link: "/achievements"
        });
      }
    }
    
    this.userAchievements.set(userAchievement.id, updatedUserAchievement);
    return updatedUserAchievement;
  }
  
  async completeUserAchievement(userId: number, achievementId: number): Promise<UserAchievement | undefined> {
    return this.updateUserAchievementProgress(userId, achievementId, 100);
  }
  
  // Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getAllRewards(): Promise<Reward[]> {
    return Array.from(this.rewards.values())
      .filter(r => r.isActive)
      .sort((a, b) => a.pointsCost - b.pointsCost); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø­Ø³Ø¨ Ø§Ù„ØªÙƒÙ„ÙØ©
  }
  
  async getReward(id: number): Promise<Reward | undefined> {
    return this.rewards.get(id);
  }
  
  async getRewardsByCategory(category: string): Promise<Reward[]> {
    return Array.from(this.rewards.values())
      .filter(r => r.category === category && r.isActive)
      .sort((a, b) => a.pointsCost - b.pointsCost);
  }
  
  async createReward(reward: InsertReward): Promise<Reward> {
    const id = this.rewardsCurrentId++;
    const newReward: Reward = { ...reward, id };
    this.rewards.set(id, newReward);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹ Ø¨Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    await this.createNotification({
      userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
      title: "Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…ØªØ§Ø­Ø©!",
      message: `ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯Ø©: ${reward.name}. ØªÙƒÙ„ÙØ©: ${reward.pointsCost} Ù†Ù‚Ø·Ø©.`,
      type: "info",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return newReward;
  }
  
  async updateReward(id: number, reward: Partial<Reward>): Promise<Reward | undefined> {
    const existingReward = this.rewards.get(id);
    if (!existingReward) return undefined;
    
    const updatedReward = { ...existingReward, ...reward };
    this.rewards.set(id, updatedReward);
    return updatedReward;
  }
  
  // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getUserRedemptions(userId: number): Promise<RewardRedemption[]> {
    return Array.from(this.rewardRedemptions.values())
      .filter(r => r.userId === userId)
      .sort((a, b) => {
        const dateA = new Date(a.redeemedAt);
        const dateB = new Date(b.redeemedAt);
        return dateB.getTime() - dateA.getTime();
      });
  }
  
  async createRedemption(redemption: InsertRewardRedemption): Promise<RewardRedemption> {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø¯ÙŠÙ‡ Ù†Ù‚Ø§Ø· ÙƒØ§ÙÙŠØ©
    const userPoints = await this.getUserRewardPoints(redemption.userId);
    const reward = await this.getReward(redemption.rewardId);
    
    if (!userPoints || !reward) {
      throw new Error("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
    }
    
    if (userPoints.availablePoints < redemption.pointsUsed) {
      throw new Error("Ø§Ù„Ù†Ù‚Ø§Ø· ØºÙŠØ± ÙƒØ§ÙÙŠØ© Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©");
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const id = this.rewardRedemptionsCurrentId++;
    const newRedemption: RewardRedemption = { 
      ...redemption, 
      id, 
      redeemedAt: new Date(),
      status: "pending"
    };
    this.rewardRedemptions.set(id, newRedemption);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† Ø¨Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    await this.createNotification({
      userId: null, // Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†
      title: "Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯",
      message: `Ù‚Ø§Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø±Ù‚Ù… ${redemption.userId} Ø¨Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}".`,
      type: "info",
      timestamp: new Date(),
      link: "/redemptions"
    });
    
    return newRedemption;
  }
  
  async approveRedemption(id: number, approverId: number): Promise<RewardRedemption | undefined> {
    const redemption = this.rewardRedemptions.get(id);
    if (!redemption || redemption.status !== "pending") return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const updatedRedemption = { 
      ...redemption, 
      status: "approved", 
      approvedBy: approverId,
      approvedAt: new Date() 
    };
    this.rewardRedemptions.set(id, updatedRedemption);
    
    // Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await this.addRewardPointsHistory({
      userId: redemption.userId,
      points: -redemption.pointsUsed, // Ù‚ÙŠÙ…Ø© Ø³Ø§Ù„Ø¨Ø© Ù„Ù„Ø®ØµÙ…
      type: "redeemed",
      reason: `Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© Ø¨Ù…Ø¹Ø±Ù ${redemption.rewardId}`,
      relatedEntityType: "redemption",
      relatedEntityId: redemption.id,
      date: new Date(),
      timestamp: new Date(),
      status: "active",
      branchId: null
    });
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ÙÙŠ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
    const reward = await this.getReward(redemption.rewardId);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    await this.createNotification({
      userId: redemption.userId,
      title: "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
      message: reward 
        ? `ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}".` 
        : "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©.",
      type: "success",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return updatedRedemption;
  }
  
  async rejectRedemption(id: number, notes?: string): Promise<RewardRedemption | undefined> {
    const redemption = this.rewardRedemptions.get(id);
    if (!redemption || redemption.status !== "pending") return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const updatedRedemption = { 
      ...redemption, 
      status: "rejected",
      notes: notes || redemption.notes
    };
    this.rewardRedemptions.set(id, updatedRedemption);
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ÙÙŠ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
    const reward = await this.getReward(redemption.rewardId);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    await this.createNotification({
      userId: redemption.userId,
      title: "ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
      message: reward
        ? `ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}". ${notes ? `Ø§Ù„Ø³Ø¨Ø¨: ${notes}` : ''}`
        : `ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©. ${notes ? `Ø§Ù„Ø³Ø¨Ø¨: ${notes}` : ''}`,
      type: "error",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return updatedRedemption;
  }
  
  async getRedemptionsByStatus(status: string): Promise<RewardRedemption[]> {
    return Array.from(this.rewardRedemptions.values())
      .filter(r => r.status === status)
      .sort((a, b) => {
        const dateA = new Date(a.redeemedAt);
        const dateB = new Date(b.redeemedAt);
        return dateA.getTime() - dateB.getTime(); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø¨Ø­ÙŠØ« Ø£Ù‚Ø¯Ù… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø£ÙˆÙ„Ø§Ù‹
      });
  }
  
  // Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
  async getActiveLeaderboards(): Promise<Leaderboard[]> {
    return Array.from(this.leaderboards.values())
      .filter(l => l.isActive)
      .sort((a, b) => {
        const dateA = new Date(a.endDate);
        const dateB = new Date(b.endDate);
        return dateA.getTime() - dateB.getTime(); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø¨Ø­ÙŠØ« Ø£Ù‚Ø±Ø¨ Ù…ÙˆØ¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø£ÙˆÙ„Ø§Ù‹
      });
  }
  
  async getLeaderboard(id: number): Promise<Leaderboard | undefined> {
    return this.leaderboards.get(id);
  }
  
  async createLeaderboard(leaderboard: InsertLeaderboard): Promise<Leaderboard> {
    const id = this.leaderboardsCurrentId++;
    const newLeaderboard: Leaderboard = { ...leaderboard, id, createdAt: new Date() };
    this.leaderboards.set(id, newLeaderboard);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹ Ø¨Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    await this.createNotification({
      userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
      title: "Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯Ø© Ù…ØªØ§Ø­Ø©!",
      message: `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯Ø©: "${leaderboard.name}". ØªØ¨Ø¯Ø£ Ù…Ù† ${new Date(leaderboard.startDate).toLocaleDateString('ar-SA')}.`,
      type: "info",
      timestamp: new Date(),
      link: "/leaderboards"
    });
    
    return newLeaderboard;
  }
  
  async updateLeaderboardResults(leaderboardId: number, results: InsertLeaderboardResult[]): Promise<LeaderboardResult[]> {
    const updatedResults: LeaderboardResult[] = [];
    
    for (const result of results) {
      const id = this.leaderboardResultsCurrentId++;
      // ØªØ­ÙˆÙŠÙ„ score Ùˆ metricValue Ù„ØªØ®Ø²ÙŠÙ†Ù‡Ø§ ÙƒÙ†Øµ Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const formattedResult = {
        ...result,
        score: result.score.toString(),
        metricValue: result.metricValue.toString()
      };
      const newResult: LeaderboardResult = { 
        ...formattedResult, 
        id, 
        leaderboardId,
        updateDate: new Date() 
      };
      this.leaderboardResults.set(id, newResult);
      updatedResults.push(newResult);
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±ÙƒØ² ÙÙŠ Ø§Ù„Ù…Ø±Ø§ÙƒØ² Ø§Ù„Ø«Ù„Ø§Ø«Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ØŒ Ù†Ø±Ø³Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Ù‹ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      if (result.rank <= 3) {
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù„ÙˆØ­Ø©
        const leaderboard = await this.getLeaderboard(leaderboardId);
        if (leaderboard) {
          let rankText = "";
          if (result.rank === 1) rankText = "Ø§Ù„Ø£ÙˆÙ„ ğŸ¥‡";
          else if (result.rank === 2) rankText = "Ø§Ù„Ø«Ø§Ù†ÙŠ ğŸ¥ˆ";
          else if (result.rank === 3) rankText = "Ø§Ù„Ø«Ø§Ù„Ø« ğŸ¥‰";
          
          await this.createNotification({
            userId: result.userId,
            title: "ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! Ø£Ù†Øª Ù…Ù† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†",
            message: `Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±ÙƒØ² ${rankText} ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† "${leaderboard.name}".`,
            type: "success",
            timestamp: new Date(),
            link: "/leaderboards"
          });
        }
      }
    }
    
    return updatedResults;
  }
  
  async getLeaderboardResults(leaderboardId: number): Promise<LeaderboardResult[]> {
    return Array.from(this.leaderboardResults.values())
      .filter(r => r.leaderboardId === leaderboardId)
      .sort((a, b) => a.rank - b.rank); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø±ÙƒØ²
  }
  
  async getUserLeaderboardRank(leaderboardId: number, userId: number): Promise<LeaderboardResult | undefined> {
    return Array.from(this.leaderboardResults.values())
      .find(r => r.leaderboardId === leaderboardId && r.userId === userId);
  }
  
  // ÙˆØ¸Ø§Ø¦Ù ØªØ­Ù„ÙŠÙ„ Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  async analyzeSalesDrops(branchId: number, period: string): Promise<any> {
    const today = new Date();
    let startDate = new Date();
    let endDate = new Date();
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„
    if (period === 'week') {
      // Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    } else if (period === 'month') {
      // Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
    } else if (period === 'quarter') {
      // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    } else {
      // Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹: Ø¢Ø®Ø± Ø£Ø³Ø¨ÙˆØ¹
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    }
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
    const formattedStartDate = format(startDate, 'yyyy-MM-dd');
    const formattedEndDate = format(endDate, 'yyyy-MM-dd');
    
    const sales = await this.getDailySalesByBranchAndDateRange(
      branchId, 
      formattedStartDate, 
      formattedEndDate
    );
    
    // ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…
    const salesByDay: { [key: string]: { total: number, count: number, average: number, date: string } } = {};
    
    for (const sale of sales) {
      const dateStr = sale.date;
      if (!salesByDay[dateStr]) {
        salesByDay[dateStr] = { total: 0, count: 0, average: 0, date: dateStr };
      }
      
      salesByDay[dateStr].total += sale.totalSales;
      salesByDay[dateStr].count += 1;
    }
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„ÙŠÙˆÙ…ÙŠ
    for (const day in salesByDay) {
      salesByDay[day].average = salesByDay[day].total / salesByDay[day].count;
    }
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù„ÙØªØ±Ø© ÙƒØ§Ù…Ù„Ø©
    const dailyTotals = Object.values(salesByDay).map(day => day.total);
    const overallAverage = dailyTotals.reduce((sum, total) => sum + total, 0) / dailyTotals.length || 0;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠØ§Ù… Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (Ø£Ù‚Ù„ Ù…Ù† 70% Ù…Ù† Ø§Ù„Ù…ØªÙˆØ³Ø·)
    const dropThreshold = overallAverage * 0.7;
    const salesDrops = Object.values(salesByDay)
      .filter(day => day.total < dropThreshold)
      .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    return {
      period,
      overallAverage,
      dropThreshold,
      salesDrops,
      salesByDay: Object.values(salesByDay),
      analysis: {
        totalDays: Object.keys(salesByDay).length,
        dropDays: salesDrops.length,
        dropPercentage: (salesDrops.length / Object.keys(salesByDay).length) * 100,
        worstDay: salesDrops.length > 0 ? 
          salesDrops.reduce((worst, current) => current.total < worst.total ? current : worst, salesDrops[0]) : 
          null,
        recommendations: this.generateDropRecommendations(salesDrops, overallAverage)
      }
    };
  }
  
  // ØªÙˆÙ„ÙŠØ¯ ØªÙˆØµÙŠØ§Øª Ù„Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  private generateDropRecommendations(salesDrops: any[], average: number): any[] {
    if (salesDrops.length === 0) return [];
    
    const recommendations = [];
    
    // ÙØ­Øµ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: Ù‡Ù„ Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ©ØŸ
    const consecutiveDrops = this.checkForConsecutiveDrops(salesDrops);
    if (consecutiveDrops.isConsecutive) {
      recommendations.push({
        type: 'warning',
        title: 'Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `Ù„ÙˆØ­Ø¸ Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù…Ø¯Ø© ${consecutiveDrops.days} Ø£ÙŠØ§Ù… Ù…ØªØªØ§Ù„ÙŠØ©.`,
        actions: [
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ³Ø¹ÙŠØ±',
          'ØªØ®Ø·ÙŠØ· Ø­Ù…Ù„Ø© ØªØ±ÙˆÙŠØ¬ÙŠØ© Ø¹Ø§Ø¬Ù„Ø©',
          'ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…Ù†Ø§ÙØ³ÙŠÙ†'
        ]
      });
    }
    
    // ÙØ­Øµ Ø§Ù„Ù…ÙˆØ³Ù…ÙŠØ©: Ù‡Ù„ Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…ØªÙƒØ±Ø±Ø© ÙÙŠ Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶Ø§ØªØŸ
    const weekdayPattern = this.checkForWeekdayPattern(salesDrops);
    if (weekdayPattern.hasPattern) {
      recommendations.push({
        type: 'insight',
        title: 'Ù†Ù…Ø· Ø£Ø³Ø¨ÙˆØ¹ÙŠ ÙÙŠ Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `ÙŠÙˆØ¬Ø¯ Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ù†ØªØ¸Ù… ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ Ø£ÙŠØ§Ù… ${weekdayPattern.days.join(', ')}.`,
        actions: [
          'ØªØ®Ø·ÙŠØ· Ø¹Ø±ÙˆØ¶ Ø®Ø§ØµØ© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙŠØ§Ù…',
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙŠØ§Ù…',
          'Ø¯Ø±Ø§Ø³Ø© Ø£Ù†Ù…Ø§Ø· Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡'
        ]
      });
    }
    
    // ÙØ­Øµ Ø´Ø¯Ø© Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶: Ù‡Ù„ Ù‡Ù†Ø§Ùƒ Ø£ÙŠØ§Ù… Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø´Ø¯ÙŠØ¯ØŸ
    const severeDrops = salesDrops.filter(day => day.total < (average * 0.5));
    if (severeDrops.length > 0) {
      recommendations.push({
        type: 'critical',
        title: 'Ø§Ù†Ø®ÙØ§Ø¶ Ø­Ø§Ø¯ ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `Ù‡Ù†Ø§Ùƒ ${severeDrops.length} Ø£ÙŠØ§Ù… Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø´Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (Ø£Ù‚Ù„ Ù…Ù† 50% Ù…Ù† Ø§Ù„Ù…ØªÙˆØ³Ø·).`,
        actions: [
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© (Ø§Ù„Ø·Ù‚Ø³ØŒ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø­Ù„ÙŠØ©)',
          'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø®Ø¯Ù…Ø©',
          'Ø¥Ø·Ù„Ø§Ù‚ Ø®ØµÙˆÙ…Ø§Øª Ù…Ø³ØªÙ‡Ø¯ÙØ©'
        ]
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© ØªÙˆØµÙŠØ§Øª Ø¹Ø§Ù…Ø©
    recommendations.push({
      type: 'general',
      title: 'ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…',
      message: 'ØªÙˆØµÙŠØ§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…Ø¨ÙŠØ¹Ø§Øª.',
      actions: [
        'Ù…Ø±Ø§Ø¬Ø¹Ø© ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ø´Ø§Ù…Ù„Ø©',
        'ØªØ¯Ø±ÙŠØ¨ ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø¹Ù„Ù‰ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„ÙØ¹Ø§Ù„Ø©',
        'ØªØ­Ù„ÙŠÙ„ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ø³ÙˆÙ‚'
      ]
    });
    
    return recommendations;
  }
  
  // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ©
  private checkForConsecutiveDrops(salesDrops: any[]): { isConsecutive: boolean, days: number } {
    if (salesDrops.length < 2) return { isConsecutive: false, days: 0 };
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£ÙŠØ§Ù… Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const sortedDrops = [...salesDrops].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    let maxConsecutive = 1;
    let currentConsecutive = 1;
    
    for (let i = 1; i < sortedDrops.length; i++) {
      const prevDate = new Date(sortedDrops[i-1].date);
      const currDate = new Date(sortedDrops[i].date);
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¨Ø§Ø´Ø±Ø©
      const diffTime = Math.abs(currDate.getTime() - prevDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 1) {
        currentConsecutive++;
        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
      } else {
        currentConsecutive = 1;
      }
    }
    
    return { isConsecutive: maxConsecutive >= 3, days: maxConsecutive };
  }
  
  // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ù†Ù…Ø· ÙÙŠ Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
  private checkForWeekdayPattern(salesDrops: any[]): { hasPattern: boolean, days: string[] } {
    if (salesDrops.length < 3) return { hasPattern: false, days: [] };
    
    // Ø¹Ø¯ ØªÙƒØ±Ø§Ø± ÙƒÙ„ ÙŠÙˆÙ… Ù…Ù† Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
    const weekdayCounts: Record<string, number> = {
      'Ø§Ù„Ø£Ø­Ø¯': 0, 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†': 0, 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡': 0, 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡': 0, 'Ø§Ù„Ø®Ù…ÙŠØ³': 0, 'Ø§Ù„Ø¬Ù…Ø¹Ø©': 0, 'Ø§Ù„Ø³Ø¨Øª': 0
    };
    
    const arabicDays = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©', 'Ø§Ù„Ø³Ø¨Øª'];
    
    for (const drop of salesDrops) {
      const date = new Date(drop.date);
      const dayOfWeek = date.getDay();
      weekdayCounts[arabicDays[dayOfWeek]]++;
    }
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù†Ù…Ø· (ØªÙƒØ±Ø§Ø± Ù„Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø©)
    const patternDays = Object.entries(weekdayCounts)
      .filter(([_, count]) => count >= 2)
      .map(([day, _]) => day);
    
    return { hasPattern: patternDays.length > 0, days: patternDays };
  }
  
  async generateSalesAlerts(branchId: number, threshold: number): Promise<any[]> {
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
    const today = new Date();
    const oneWeekAgo = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    
    const formattedStartDate = format(oneWeekAgo, 'yyyy-MM-dd');
    const formattedEndDate = format(today, 'yyyy-MM-dd');
    
    const sales = await this.getDailySalesByBranchAndDateRange(
      branchId,
      formattedStartDate,
      formattedEndDate
    );
    
    if (sales.length === 0) return [];
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø­Ø¯Ø« Ù‡Ø¯Ù Ø´Ù‡Ø±ÙŠ
    const currentMonth = today.getMonth() + 1;
    const currentYear = today.getFullYear();
    const monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, currentMonth, currentYear);
    
    if (!monthlyTarget) return [];
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
    const avgDailySales = totalSales / sales.length;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ (ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø£ÙŠØ§Ù… Ø§Ù„Ø´Ù‡Ø±)
    const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
    const dailyTarget = monthlyTarget.targetAmount / daysInMonth;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ù‡Ø¯Ù
    const alerts = [];
    
    if (avgDailySales < (dailyTarget * (threshold / 100))) {
      // Ø¥Ù†Ø´Ø§Ø¡ ØªÙ†Ø¨ÙŠÙ‡ Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
      const percentageOfTarget = (avgDailySales / dailyTarget) * 100;
      
      const branch = await this.getBranch(branchId);
      const branchName = branch ? branch.name : `ÙØ±Ø¹ #${branchId}`;
      
      alerts.push({
        id: `sales-drop-${Date.now()}`,
        branchId,
        branchName,
        date: format(today, 'yyyy-MM-dd'),
        severity: percentageOfTarget < 50 ? 'critical' : percentageOfTarget < 70 ? 'high' : 'medium',
        type: 'sales_drop',
        metric: {
          current: avgDailySales,
          expected: dailyTarget,
          difference: dailyTarget - avgDailySales,
          percentageChange: ((dailyTarget - avgDailySales) / dailyTarget) * 100
        },
        recommendations: [
          {
            id: "rec1",
            text: "Ø¥Ø¬Ø±Ø§Ø¡ ØªØ®ÙÙŠØ¶Ø§Øª Ù…Ø¤Ù‚ØªØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± Ù…Ø¨ÙŠØ¹Ø§Ù‹",
            priority: "high",
            impact: 80
          },
          {
            id: "rec2",
            text: "ØªÙ†Ø´ÙŠØ· Ø­Ù…Ù„Ø© ØªØ³ÙˆÙŠÙ‚ Ø¹Ù„Ù‰ ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ",
            priority: "medium",
            impact: 65
          },
          {
            id: "rec3",
            text: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ø¯ÙˆÙ„ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† Ù„Ø¶Ù…Ø§Ù† ØªØºØ·ÙŠØ© Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø°Ø±ÙˆØ©",
            priority: "medium",
            impact: 60
          }
        ],
        details: `Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠ (${avgDailySales.toFixed(2)}) Ø£Ù‚Ù„ Ù…Ù† ${threshold}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ (${dailyTarget.toFixed(2)})`
      });
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¨Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶
      await this.createNotification({
        userId: null, // Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†
        title: "âš ï¸ ØªÙ†Ø¨ÙŠÙ‡: Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
        message: `Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ${branchName} Ø¥Ù„Ù‰ ${percentageOfTarget.toFixed(1)}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ.`,
        type: "warning",
        timestamp: new Date(),
        link: "/smart-alerts"
      });
    }
    
    return alerts;
  }
  
  async analyzeCashierPerformanceTrends(branchId: number, period: string): Promise<any[]> {
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† ÙÙŠ Ø§Ù„ÙØ±Ø¹
    const users = await this.getUsers();
    const cashiers = users.filter(user => user.role === 'cashier' && user.branchId === branchId);
    
    if (cashiers.length === 0) return [];
    
    // ØªØ­Ø¯ÙŠØ¯ Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„Ù„ØªØ­Ù„ÙŠÙ„
    const today = new Date();
    let startDate = new Date();
    
    if (period === 'week') {
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    } else if (period === 'month') {
      startDate = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
    } else if (period === 'quarter') {
      startDate = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    } else {
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    }
    
    const formattedStartDate = format(startDate, 'yyyy-MM-dd');
    const formattedEndDate = format(today, 'yyyy-MM-dd');
    
    // ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ ÙƒÙ„ ÙƒØ§Ø´ÙŠØ±
    const cashiersAnalysis = [];
    
    for (const cashier of cashiers) {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ø©
      const sales = await this.getDailySalesByBranchAndDateRange(
        branchId,
        formattedStartDate,
        formattedEndDate
      ).then(allSales => allSales.filter(sale => sale.cashierId === cashier.id));
      
      if (sales.length === 0) continue;
      
      // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙˆÙ†Ø³Ø¨Ø© Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù ÙˆØ§Ù„Ù…ØªÙˆØ³Ø·
      const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
      const avgSales = totalSales / sales.length;
      
      const totalTransactions = sales.reduce((sum, sale) => sum + sale.totalTransactions, 0);
      const avgTransactions = totalTransactions / sales.length;
      
      const avgTicket = totalSales / totalTransactions;
      
      // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ù„Øº Ø§Ù„Ù†Ù‚Ø¯ÙŠØ© (Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©)
      const totalDiscrepancy = sales.reduce((sum, sale) => {
        return sum + (sale.discrepancy ? Math.abs(sale.discrepancy) : 0);
      }, 0);
      const avgDiscrepancy = sales.length > 0 ? totalDiscrepancy / sales.length : 0;
      
      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: Ù‡Ù„ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ± ÙŠØªØ­Ø³Ù† Ø£Ùˆ ÙŠØªØ±Ø§Ø¬Ø¹ØŸ
      const trend = this.analyzeCashierTrend(sales);
      
      // ØªØ­Ù„ÙŠÙ„ Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© ÙˆØ§Ù„Ø¶Ø¹Ù
      const strengths = [];
      const weaknesses = [];
      
      if (avgTicket > 30) strengths.push('Ù‚ÙŠÙ…Ø© Ù…ØªÙˆØ³Ø· Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ø±ØªÙØ¹Ø©');
      if (avgDiscrepancy < 5) strengths.push('Ø§Ù†Ø­Ø±Ø§Ù Ù†Ù‚Ø¯ÙŠ Ù…Ù†Ø®ÙØ¶');
      if (trend.salesTrend === 'up') strengths.push('Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ØªØ­Ø³Ù†');
      
      if (avgTicket < 20) weaknesses.push('Ù‚ÙŠÙ…Ø© Ù…ØªÙˆØ³Ø· Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ù†Ø®ÙØ¶Ø©');
      if (avgDiscrepancy > 20) weaknesses.push('Ø§Ù†Ø­Ø±Ø§Ù Ù†Ù‚Ø¯ÙŠ Ù…Ø±ØªÙØ¹');
      if (trend.salesTrend === 'down') weaknesses.push('Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ØªØ±Ø§Ø¬Ø¹');
      
      // ØªÙ‚Ø¯ÙŠÙ… ØªÙˆØµÙŠØ§Øª ØªØ¯Ø±ÙŠØ¨ÙŠØ©
      const trainingRecommendations = [];
      
      if (avgTicket < 20) {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…ØªÙ‚Ø§Ø·Ø¹ Ù„Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø¨');
      }
      
      if (avgDiscrepancy > 20) {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø¯ ÙˆØ§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª');
      }
      
      if (trend.salesTrend === 'down') {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ Ù…Ù‡Ø§Ø±Ø§Øª Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©');
      }
      
      // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©
      const suggestedRewardPoints = this.calculateSuggestedRewardPoints(
        avgSales, avgDiscrepancy, trend.consistency
      );
      
      cashiersAnalysis.push({
        cashierId: cashier.id,
        cashierName: cashier.name,
        period,
        metrics: {
          totalSales,
          totalTransactions,
          averageDailySales: avgSales,
          averageTicket: avgTicket,
          averageDiscrepancy: avgDiscrepancy,
          daysLogged: sales.length
        },
        trends: trend,
        performance: {
          strengths,
          weaknesses,
          trainingRecommendations,
          suggestedRewardPoints
        }
      });
    }
    
    return cashiersAnalysis;
  }
  
  // ØªØ­Ù„ÙŠÙ„ Ø§ØªØ¬Ø§Ù‡ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ±
  private analyzeCashierTrend(sales: DailySales[]): any {
    if (sales.length < 3) {
      return { salesTrend: 'stable', consistency: 'medium' };
    }
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const sortedSales = [...sales].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù†ØµÙ Ø§Ù„Ø£ÙˆÙ„ ÙˆØ§Ù„Ù†ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    const halfIndex = Math.floor(sortedSales.length / 2);
    const firstHalf = sortedSales.slice(0, halfIndex);
    const secondHalf = sortedSales.slice(halfIndex);
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„ÙƒÙ„ Ù†ØµÙ
    const firstHalfAvg = firstHalf.reduce((sum, sale) => sum + sale.totalSales, 0) / firstHalf.length;
    const secondHalfAvg = secondHalf.reduce((sum, sale) => sum + sale.totalSales, 0) / secondHalf.length;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    let salesTrend = 'stable';
    if (secondHalfAvg > (firstHalfAvg * 1.1)) {
      salesTrend = 'up';
    } else if (secondHalfAvg < (firstHalfAvg * 0.9)) {
      salesTrend = 'down';
    }
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ³Ø§Ù‚
    const allSales = sortedSales.map(sale => sale.totalSales);
    const mean = allSales.reduce((sum, val) => sum + val, 0) / allSales.length;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ
    const squaredDiffs = allSales.map(val => Math.pow(val - mean, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / squaredDiffs.length;
    const stdDev = Math.sqrt(avgSquaredDiff);
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ø®ØªÙ„Ø§Ù (CV)
    const cv = (stdDev / mean) * 100;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ³Ø§Ù‚ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ø®ØªÙ„Ø§Ù
    let consistency = 'medium';
    if (cv < 15) {
      consistency = 'high';
    } else if (cv > 30) {
      consistency = 'low';
    }
    
    return {
      salesTrend,
      consistency,
      changePercentage: ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100,
      coefficientOfVariation: cv
    };
  }
  
  // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©
  private calculateSuggestedRewardPoints(avgSales: number, avgDiscrepancy: number, consistency: string): number {
    let points = 0;
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
    if (avgSales > 1000) {
      points += 30;
    } else if (avgSales > 500) {
      points += 20;
    } else if (avgSales > 250) {
      points += 10;
    }
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù
    if (avgDiscrepancy < 5) {
      points += 20;
    } else if (avgDiscrepancy < 20) {
      points += 10;
    }
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØ³Ø§Ù‚
    if (consistency === 'high') {
      points += 20;
    } else if (consistency === 'medium') {
      points += 10;
    }
    
    return points;
  }
  
  async initializeDemoData(): Promise<void> {
    // ØªÙ†ÙÙŠØ° Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª ØªØ¬Ø±ÙŠØ¨ÙŠØ©
    console.log("Initializing demo data in memory storage");
    
    // Ø¥Ø¶Ø§ÙØ© Ù„ÙˆØ­Ø§Øª Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©
    const today = new Date();
    const nextMonth = new Date(today);
    nextMonth.setMonth(today.getMonth() + 1);
    
    // Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠØ©
    this.createLeaderboard({
      name: "ØªØ­Ø¯ÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠ",
      description: "Ø§Ù„Ù…ØªØµØ¯Ø±ÙˆÙ† ÙÙŠ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ",
      type: "monthly",
      category: "sales",
      startDate: today,
      endDate: nextMonth,
      isActive: true
    });
    
    // Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡
    const nextWeek = new Date(today);
    nextWeek.setDate(today.getDate() + 7);
    this.createLeaderboard({
      name: "Ù†Ø¬ÙˆÙ… Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡",
      description: "Ø§Ù„Ù…ØªÙ…ÙŠØ²ÙˆÙ† ÙÙŠ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡",
      type: "weekly",
      category: "customer_satisfaction",
      startDate: today,
      endDate: nextWeek,
      isActive: true
    });
    
    // Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù
    const endQuarter = new Date(today);
    endQuarter.setMonth(Math.floor(today.getMonth() / 3) * 3 + 3);
    this.createLeaderboard({
      name: "Ø§Ù„Ø£ÙØ¶Ù„ ÙÙŠ ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù",
      description: "Ø§Ù„ÙØ±ÙˆØ¹ Ø§Ù„Ù…ØªÙ…ÙŠØ²Ø© ÙÙŠ ØªØ­Ù‚ÙŠÙ‚ Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
      type: "quarterly",
      category: "target_achievement",
      startDate: today,
      endDate: endQuarter,
      isActive: true
    });
    
    // Ø¥Ø¶Ø§ÙØ© Ù†ØªØ§Ø¦Ø¬ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©
    if (this.leaderboards.size > 0) {
      const leaderboardId = 1; // Ø£ÙˆÙ„ Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ†
      
      // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©
      const results = [
        {
          userId: 1,
          leaderboardId,
          rank: 1,
          score: 9850,
          metricName: "Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
          metricValue: 9850,
          updateDate: new Date()
        },
        {
          userId: 2,
          leaderboardId,
          rank: 2,
          score: 7500,
          metricName: "Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
          metricValue: 7500,
          updateDate: new Date()
        },
        {
          userId: 3,
          leaderboardId,
          rank: 3,
          score: 6200,
          metricName: "Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
          metricValue: 6200,
          updateDate: new Date()
        },
        {
          userId: 4,
          leaderboardId,
          rank: 4,
          score: 5100,
          metricName: "Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
          metricValue: 5100,
          updateDate: new Date()
        },
        {
          userId: 5,
          leaderboardId,
          rank: 5,
          score: 4300,
          metricName: "Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
          metricValue: 4300,
          updateDate: new Date()
        }
      ];
      
      try {
        this.updateLeaderboardResults(leaderboardId, results);
      } catch (error) {
        console.error("Error initializing leaderboard results:", error);
      }
    }
  }
}

export class DatabaseStorage implements IStorage {
  async deleteUser(id: number): Promise<boolean> {
    try {
      await db.delete(users).where(eq(users.id, id));
      return true;
    } catch (error) {
      console.error("Error deleting user:", error);
      return false;
    }
  }

  async getUser(id: number): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }

  async getUsers(): Promise<User[]> {
    return db.select().from(users);
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }

  async createUser(user: InsertUser): Promise<User> {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }

  async updateUser(id: number, userData: Partial<User>): Promise<User | undefined> {
    const [updatedUser] = await db
      .update(users)
      .set(userData)
      .where(eq(users.id, id))
      .returning();
    
    return updatedUser || undefined;
  }

  async getBranch(id: number): Promise<Branch | undefined> {
    const result = await db.select().from(branches).where(eq(branches.id, id));
    return result[0];
  }

  async getBranches(): Promise<Branch[]> {
    return db.select().from(branches);
  }

  async createBranch(branch: InsertBranch): Promise<Branch> {
    const [newBranch] = await db.insert(branches).values(branch).returning();
    return newBranch;
  }

  async updateBranch(id: number, branchData: Partial<Branch>): Promise<Branch | undefined> {
    const [updatedBranch] = await db
      .update(branches)
      .set(branchData)
      .where(eq(branches.id, id))
      .returning();
    
    return updatedBranch || undefined;
  }

  async getMonthlyTarget(id: number): Promise<MonthlyTarget | undefined> {
    const result = await db.select().from(monthlyTargets).where(eq(monthlyTargets.id, id));
    return result[0];
  }

  async getMonthlyTargets(): Promise<MonthlyTarget[]> {
    return db.select().from(monthlyTargets);
  }

  async getMonthlyTargetByBranchAndDate(branchId: number, month: number, year: number): Promise<MonthlyTarget | undefined> {
    const result = await db
      .select()
      .from(monthlyTargets)
      .where(
        and(
          eq(monthlyTargets.branchId, branchId),
          eq(monthlyTargets.month, month),
          eq(monthlyTargets.year, year)
        )
      );
    
    return result[0];
  }

  async createMonthlyTarget(target: InsertMonthlyTarget): Promise<MonthlyTarget> {
    try {
      // ØªØ­ÙˆÙŠÙ„ ÙˆØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù†ØµÙŠØ© ÙˆØ§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
      const formattedTarget = {
        branchId: Number(target.branchId),
        month: Number(target.month),
        year: Number(target.year),
        targetAmount: Number(target.targetAmount),
        weekdayWeights: typeof target.weekdayWeights === 'object' ? target.weekdayWeights : {},
        dailyTargets: typeof target.dailyTargets === 'object' ? target.dailyTargets : {},
        specialDays: Array.isArray(target.specialDays) ? target.specialDays : [],
        distributionPattern: typeof target.distributionPattern === 'object' ? target.distributionPattern : {}
      };
      
      console.log('Formatted target before insert:', JSON.stringify(formattedTarget, null, 2));
      
      const [newTarget] = await db.insert(monthlyTargets).values(formattedTarget).returning();
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø³Ø¬Ù„ Ù†Ø´Ø§Ø· Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
      console.log('Created monthly target:', JSON.stringify(newTarget, null, 2));
      
      return newTarget;
    } catch (error) {
      console.error('Error in createMonthlyTarget:', error);
      throw error;
    }
  }

  async getDailySales(): Promise<DailySales[]> {
    return db.select().from(dailySales);
  }

  async getDailySalesById(id: number): Promise<DailySales | undefined> {
    const result = await db.select().from(dailySales).where(eq(dailySales.id, id));
    return result[0];
  }

  async getDailySalesByBranchAndDate(branchId: number, date: string): Promise<DailySales[]> {
    return db
      .select()
      .from(dailySales)
      .where(
        and(
          eq(dailySales.branchId, branchId),
          eq(dailySales.date, date)
        )
      );
  }

  async getDailySalesByBranchAndDateRange(branchId: number, startDate: string, endDate: string): Promise<DailySales[]> {
    return db
      .select()
      .from(dailySales)
      .where(
        and(
          eq(dailySales.branchId, branchId),
          gte(dailySales.date, startDate),
          lte(dailySales.date, endDate)
        )
      );
  }

  async getDailySalesByCashierAndDate(cashierId: number, date: string): Promise<DailySales | undefined> {
    const result = await db
      .select()
      .from(dailySales)
      .where(
        and(
          eq(dailySales.cashierId, cashierId),
          eq(dailySales.date, date)
        )
      );
    
    return result[0];
  }

  async createDailySales(sales: InsertDailySales): Promise<DailySales> {
    try {
      console.log("Original sales data:", JSON.stringify(sales));
      // ØªØ­ÙˆÙŠÙ„ shiftStart Ùˆ shiftEnd Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù†Ø§Øª Date Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø³Ù„Ø³Ù„Ø© Ù†ØµÙŠØ©
      const salesData: any = { 
        date: sales.date,
        branchId: sales.branchId,
        cashierId: sales.cashierId,
        status: sales.status || "pending",
        shiftType: sales.shiftType || "morning",
        totalCashSales: sales.totalCashSales || 0,
        totalNetworkSales: sales.totalNetworkSales || 0,
        totalSales: sales.totalSales || 0,
        totalTransactions: sales.totalTransactions || 0
      };
      
      if (sales.shiftStart) {
        if (typeof sales.shiftStart === 'string') {
          salesData.shiftStart = new Date(sales.shiftStart);
        } else {
          salesData.shiftStart = sales.shiftStart;
        }
      }
      
      if (sales.shiftEnd) {
        if (typeof sales.shiftEnd === 'string') {
          salesData.shiftEnd = new Date(sales.shiftEnd);
        } else {
          salesData.shiftEnd = sales.shiftEnd;
        }
      }
      
      if (sales.startingCash !== undefined) salesData.startingCash = sales.startingCash;
      if (sales.actualCashInRegister !== undefined) salesData.actualCashInRegister = sales.actualCashInRegister;
      if (sales.discrepancy !== undefined) salesData.discrepancy = sales.discrepancy;
      if (sales.averageTicket !== undefined) salesData.averageTicket = sales.averageTicket;
      if (sales.signature !== undefined) salesData.signature = sales.signature;
      if (sales.notes !== undefined) salesData.notes = sales.notes;
      if (sales.hasDiscrepancyAcknowledgment !== undefined) salesData.hasDiscrepancyAcknowledgment = sales.hasDiscrepancyAcknowledgment;
      
      console.log("Processed sales data:", JSON.stringify(salesData));
      
      // ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
      const [newSale] = await db.insert(dailySales).values(salesData).returning();
      
      // ØªØ­Ø¯ÙŠØ« Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      try {
        console.log("Updating target with sales:", JSON.stringify(newSale));
        await this.updateMonthlyTargetFromSales(newSale);
      } catch (updateError) {
        console.error("Error updating target:", updateError);
      }
      
      return newSale;
    } catch (error) {
      console.error("Error in createDailySales:", error);
      throw error;
    }
  }
  
  async checkExistingDailySales(cashierId: number, date: string): Promise<boolean> {
    const result = await db
      .select()
      .from(dailySales)
      .where(
        and(
          eq(dailySales.cashierId, cashierId),
          eq(dailySales.date, date)
        )
      );
    
    return result.length > 0;
  }
  
  async updateDailySalesStatus(id: number, status: string, consolidatedId?: number): Promise<DailySales | undefined> {
    try {
      const updateData: any = { status };
      
      if (consolidatedId !== undefined) {
        updateData.consolidatedId = consolidatedId;
      }
      
      const [updatedSale] = await db
        .update(dailySales)
        .set(updateData)
        .where(eq(dailySales.id, id))
        .returning();
      
      return updatedSale;
    } catch (error) {
      console.error("Error updating daily sales status:", error);
      return undefined;
    }
  }
  
  /**
   * ØªØ­Ø¯ÙŠØ« Ù‡Ø¯Ù Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø¹Ù†Ø¯Ù…Ø§ ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ù…Ø¨ÙŠØ¹Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©
   * Ù†Ø³Ø®Ø© Ù…Ø­Ø³Ù†Ø© Ù…Ù† ÙˆØ¸ÙŠÙØ© updateTargetWithSales
   */
  private async updateMonthlyTargetFromSales(sales: DailySales): Promise<void> {
    try {
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø´Ù‡Ø± ÙˆØ§Ù„Ø³Ù†Ø© Ù…Ù† ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
      const saleDate = new Date(sales.date);
      const month = saleDate.getMonth() + 1; // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ù‡Ø± Ù…Ù† 0-11 Ø¥Ù„Ù‰ 1-12
      const year = saleDate.getFullYear();
      
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ Ù„Ù„ÙØ±Ø¹ ÙˆØ§Ù„Ø´Ù‡Ø± ÙˆØ§Ù„Ø³Ù†Ø©
      const target = await this.getMonthlyTargetByBranchAndDate(sales.branchId, month, year);
      
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ Ù‡Ø¯Ù Ù…Ø·Ø§Ø¨Ù‚ØŒ Ù†Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø¯Ø§Ù„Ø©
      if (!target) {
        console.log(`No target found for branch ${sales.branchId} in ${month}/${year}`);
        return;
      }
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„ÙØ±Ø¹ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±
      const startOfMonthDate = new Date(year, month - 1, 1);
      const endOfMonthDate = new Date(year, month, 0);
      
      // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·Ø±ÙŠÙ‚Ø© Ø¨Ø¯ÙŠÙ„Ø© Ø¹Ù† format
      const startDate = startOfMonthDate.toISOString().split('T')[0];
      const endDate = endOfMonthDate.toISOString().split('T')[0];
      
      console.log(`Fetching sales for branch ${sales.branchId} from ${startDate} to ${endDate}`);
      
      const monthlySales = await this.getDailySalesByBranchAndDateRange(
        sales.branchId,
        startDate,
        endDate
      );
      
      // ØªØ¬Ù…ÙŠØ¹ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±
      const totalMonthlySales = monthlySales.reduce(
        (total, sale) => total + (sale.totalSales || 0),
        0
      );
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠØ© Ù‚Ø¨Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      const previousMonthlySales = totalMonthlySales - sales.totalSales;
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ø³Ø¨ Ø§Ù„Ù…Ø¦ÙˆÙŠØ© Ù„Ù„Ø¥Ù†Ø¬Ø§Ø²
      const previousPercentage = (previousMonthlySales / target.targetAmount) * 100;
      const currentPercentage = (totalMonthlySales / target.targetAmount) * 100;
      
      console.log(`Branch ${sales.branchId} target achievement: ${previousPercentage.toFixed(1)}% -> ${currentPercentage.toFixed(1)}%`);
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø§Ù„ØªØ­Ø¯ÙŠØ«
      await this.createActivity({
        userId: sales.cashierId,
        action: "target_update_from_sales",
        details: { 
          branchId: sales.branchId, 
          month, 
          year, 
          saleAmount: sales.totalSales,
          totalMonthlySales,
          targetAmount: target.targetAmount,
          previousPercentage: previousPercentage,
          currentPercentage: currentPercentage
        },
        branchId: sales.branchId,
        timestamp: new Date()
      });
      
      // Ø¹Ù„Ø§Ù…Ø§Øª Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ØªÙŠ Ù†Ø±ÙŠØ¯ ØªØªØ¨Ø¹Ù‡Ø§
      const milestones = [50, 75, 90, 100];
      
      // ÙØ­Øµ Ù…Ø§ Ø¥Ø°Ø§ ØªÙ… ØªØ¬Ø§ÙˆØ² Ø£ÙŠ Ù…Ù† Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ø¨Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
      for (const milestone of milestones) {
        if (currentPercentage >= milestone && previousPercentage < milestone) {
          console.log(`Milestone achieved: ${milestone}% for branch ${sales.branchId}`);
          
          // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø­Ù„Ø©
          const notificationType = milestone >= 100 ? "success" : "info";
          
          // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹
          await this.createNotification({
            userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
            title: `ØªÙ… ØªØ­Ù‚ÙŠÙ‚ ${milestone}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ`,
            message: `Ø§Ù„ÙØ±Ø¹ ${sales.branchId} Ø­Ù‚Ù‚ ${currentPercentage.toFixed(1)}% Ù…Ù† Ù‡Ø¯Ù Ø´Ù‡Ø± ${month}/${year}`,
            type: notificationType,
            timestamp: new Date(),
            link: "/targets"
          });
          
          // Ø§Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„Ø­Ù„Ù‚Ø© Ø¨Ø¹Ø¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ù…Ù„Ø§Ø¦Ù…
          break;
        }
      }
      
    } catch (error) {
      console.error("Error updating monthly target from sales:", error);
    }
  }

  // Activities
  async getActivities(limit?: number): Promise<Activity[]> {
    const query = db.select().from(activities).orderBy(desc(activities.timestamp));
    
    if (limit) {
      return query.limit(limit);
    }
    
    return query;
  }

  async getActivitiesByBranch(branchId: number, limit?: number): Promise<Activity[]> {
    const query = db
      .select()
      .from(activities)
      .where(eq(activities.branchId, branchId))
      .orderBy(desc(activities.timestamp));
    
    if (limit) {
      return query.limit(limit);
    }
    
    return query;
  }

  async createActivity(activity: InsertActivity): Promise<Activity> {
    const [newActivity] = await db.insert(activities).values(activity).returning();
    return newActivity;
  }

  // Notifications
  async getNotifications(limit?: number): Promise<Notification[]> {
    const query = db.select().from(notifications).orderBy(desc(notifications.timestamp));
    
    if (limit) {
      return query.limit(limit);
    }
    
    return query;
  }

  async getNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]> {
    let query;
    
    if (userId) {
      query = db
        .select()
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.timestamp));
    } else {
      query = db
        .select()
        .from(notifications)
        .orderBy(desc(notifications.timestamp));
    }
    
    if (limit) {
      return query.limit(limit);
    }
    
    return query;
  }

  async getUnreadNotificationsByUser(userId?: number, limit?: number): Promise<Notification[]> {
    let query;
    
    if (userId) {
      query = db
        .select()
        .from(notifications)
        .where(
          and(
            eq(notifications.userId, userId),
            eq(notifications.isRead, false)
          )
        )
        .orderBy(desc(notifications.timestamp));
    } else {
      query = db
        .select()
        .from(notifications)
        .where(eq(notifications.isRead, false))
        .orderBy(desc(notifications.timestamp));
    }
    
    if (limit) {
      return query.limit(limit);
    }
    
    return query;
  }

  async markNotificationAsRead(id: number): Promise<Notification | undefined> {
    const [updatedNotification] = await db
      .update(notifications)
      .set({ isRead: true })
      .where(eq(notifications.id, id))
      .returning();
    
    return updatedNotification || undefined;
  }

  async createNotification(notification: InsertNotification): Promise<Notification> {
    const [newNotification] = await db.insert(notifications).values(notification).returning();
    return newNotification;
  }

  // Dashboard Stats
  async getDashboardStats(branchId: number, date: Date): Promise<DashboardStats> {
    const formattedDate = format(date, 'yyyy-MM-dd');
    const currentMonth = date.getMonth() + 1;
    const currentYear = date.getFullYear();
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…
    const dailySalesData = await this.getDailySalesByBranchAndDate(branchId, formattedDate);
    const dailySalesTotal = dailySalesData.reduce((sum, sale) => sum + sale.totalSales, 0);
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ
    const monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, currentMonth, currentYear);
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ Ø§Ø³ØªÙ†Ø§Ø¯Ø§Ù‹ Ø¥Ù„Ù‰ Ù†Ù…Ø· Ø§Ù„ØªÙˆØ²ÙŠØ¹ Ø£Ùˆ Ø§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ø¨Ø³ÙŠØ·Ø©
    let dailyTarget = 0;
    if (monthlyTarget) {
      const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
      dailyTarget = monthlyTarget.targetAmount / daysInMonth;
    }
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ù‡Ø±ÙŠØ© Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†
    const startOfMonthDate = format(startOfMonth(date), 'yyyy-MM-dd');
    const endOfMonthDate = format(endOfMonth(date), 'yyyy-MM-dd');
    const monthlySalesData = await this.getDailySalesByBranchAndDateRange(branchId, startOfMonthDate, endOfMonthDate);
    const monthlySalesTotal = monthlySalesData.reduce((sum, sale) => sum + sale.totalSales, 0);
    
    // Ø­Ø³Ø§Ø¨ ØªÙˆØ²ÙŠØ¹ ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„Ø¯ÙØ¹
    const totalCash = dailySalesData.reduce((sum, sale) => sum + sale.totalCashSales, 0);
    const totalNetwork = dailySalesData.reduce((sum, sale) => {
      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ù‚Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…ØªÙˆÙØ±ØŒ Ø§Ø³ØªØ®Ø¯Ù…Ù‡. ÙˆØ¥Ù„Ø§ØŒ Ø§Ø¬Ù…Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
      if (typeof sale.totalNetworkSales !== 'undefined') {
        return sum + sale.totalNetworkSales;
      } else {
        // Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø¯ÙŠÙ… - Ù†Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ…Ø© ØµÙØ±
        return sum + 0;
      }
    }, 0);
    
    const total = totalCash + totalNetwork;
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø© ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª
    const totalTransactions = dailySalesData.reduce((sum, sale) => sum + sale.totalTransactions, 0);
    const averageTicket = totalTransactions > 0 ? dailySalesTotal / totalTransactions : 0;
    
    // Ø­Ø³Ø§Ø¨ Ø¥Ø¬Ù…Ø§Ù„ÙŠ ÙØ±Ù‚ Ø§Ù„Ù†Ù‚Ø¯ÙŠØ© (Ø§Ù„ÙØ§Ø¦Ø¶ Ø£Ùˆ Ø§Ù„Ø¹Ø¬Ø²)
    const totalCashDiscrepancy = dailySalesData.reduce((sum, sale) => {
      // ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø­Ù‚Ù„ discrepancy Ù…ÙˆØ¬ÙˆØ¯ ÙˆÙ„ÙŠØ³ null
      return sum + (sale.discrepancy !== null && sale.discrepancy !== undefined ? sale.discrepancy : 0);
    }, 0);
    
    return {
      dailySales: dailySalesTotal,
      dailyTarget,
      dailyTargetPercentage: dailyTarget > 0 ? (dailySalesTotal / dailyTarget) * 100 : 0,
      monthlyTargetAmount: monthlyTarget?.targetAmount || 0,
      monthlySalesAmount: monthlySalesTotal,
      monthlyTargetPercentage: monthlyTarget?.targetAmount ? (monthlySalesTotal / monthlyTarget.targetAmount) * 100 : 0,
      averageTicket,
      totalTransactions,
      cashDiscrepancy: totalCashDiscrepancy,
      paymentMethodsBreakdown: {
        cash: { 
          amount: totalCash, 
          percentage: total > 0 ? (totalCash / total) * 100 : 0 
        },
        network: { 
          amount: totalNetwork, 
          percentage: total > 0 ? (totalNetwork / total) * 100 : 0 
        }
      }
    };
  }

  async getBranchTargetAchievement(month: number, year: number): Promise<any[]> {
    const branchesList = await this.getBranches();
    const results = [];
    
    for (const branch of branchesList) {
      const target = await this.getMonthlyTargetByBranchAndDate(branch.id, month, year);
      
      if (target) {
        const startDateStr = format(new Date(year, month - 1, 1), 'yyyy-MM-dd');
        const endDateStr = format(endOfMonth(new Date(year, month - 1, 1)), 'yyyy-MM-dd');
        
        const sales = await this.getDailySalesByBranchAndDateRange(branch.id, startDateStr, endDateStr);
        const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
        const achievementPercentage = (totalSales / target.targetAmount) * 100;
        
        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
        let status = "ÙŠØ­ØªØ§Ø¬ ØªØ­Ø³ÙŠÙ†"; // Needs improvement
        if (achievementPercentage >= 95) {
          status = "Ù…Ù…ØªØ§Ø²"; // Excellent
        } else if (achievementPercentage >= 85) {
          status = "Ø¬ÙŠØ¯ Ø¬Ø¯Ù‹Ø§"; // Very good
        } else if (achievementPercentage >= 75) {
          status = "Ø¬ÙŠØ¯"; // Good
        }
        
        results.push({
          branchId: branch.id,
          branchName: branch.name,
          targetAmount: target.targetAmount,
          currentSales: totalSales,
          achievement: achievementPercentage,
          status
        });
      }
    }
    
    return results;
  }

  async getCashierPerformance(branchId: number, date: Date): Promise<any[]> {
    const formattedDate = format(date, "yyyy-MM-dd");
    let cashiers = [];
    
    try {
      // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId ÙŠØ³Ø§ÙˆÙŠ 0ØŒ Ù†Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹
      if (branchId === 0) {
        cashiers = await db.select().from(users).where(eq(users.role, "cashier"));
      } else {
        // ÙÙ„ØªØ±Ø© Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
        cashiers = await db.select().from(users).where(
          and(
            eq(users.role, "cashier"),
            eq(users.branchId, branchId)
          )
        );
      }
      
      const results = [];
      
      for (const cashier of cashiers) {
        // Ø§Ø³ØªØ¹Ù„Ø§Ù… Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù„ÙƒØ§Ø´ÙŠØ±
        const dailySalesQuery = await db.select().from(dailySales).where(
          and(
            eq(dailySales.cashierId, cashier.id),
            eq(dailySales.date, formattedDate)
          )
        );
        
        const salesData = dailySalesQuery[0];
        
        if (salesData) {
          // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØ±Ø¹ Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªØ¬Ù…ÙŠØ¹ÙŠ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† branchId = 0
          let branchData;
          if (branchId === 0) {
            branchData = await db.select().from(branches).where(eq(branches.id, salesData.branchId));
          }
          
          results.push({
            cashierId: cashier.id,
            name: cashier.name,
            avatar: cashier.avatar,
            // Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† branchId = 0 (Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹)
            branchId: salesData.branchId,
            branchName: branchId === 0 ? (branchData?.[0]?.name || "") : undefined,
            shiftStart: salesData.shiftStart,
            shiftEnd: salesData.shiftEnd,
            totalSales: salesData.totalSales,
            discrepancy: salesData.discrepancy || 0,
            totalTransactions: salesData.totalTransactions,
            averageTicket: salesData.averageTicket,
            performance: salesData.discrepancy === 0 ? 100 : salesData.discrepancy < 0 ? 85 : 90
          });
        }
      }
      
      // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§)
      results.sort((a, b) => b.totalSales - a.totalSales);
      
      return results;
    } catch (error) {
      console.error("Error in getCashierPerformance:", error);
      return [];
    }
  }

  async getSalesAnalytics(branchId: number, period: string): Promise<any> {
    const today = new Date();
    let startDate: Date;
    let endDate = today;
    let format_pattern = 'dd/MM';
    
    switch (period) {
      case 'weekly':
        startDate = startOfWeek(today, { weekStartsOn: 6 }); // ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…Ù† ÙŠÙˆÙ… Ø§Ù„Ø³Ø¨Øª
        endDate = endOfWeek(today, { weekStartsOn: 6 });
        format_pattern = 'EEE'; // Ø§Ø³Ù… Ø§Ù„ÙŠÙˆÙ… (Ø§Ù„Ø³Ø¨ØªØŒ Ø§Ù„Ø£Ø­Ø¯ØŒ Ø¥Ù„Ø®)
        break;
      case 'monthly':
        startDate = startOfMonth(today);
        endDate = endOfMonth(today);
        format_pattern = 'dd/MM';
        break;
      case 'yearly':
        startDate = new Date(today.getFullYear(), 0, 1);
        endDate = new Date(today.getFullYear(), 11, 31);
        format_pattern = 'MMM'; // Ø§Ø³Ù… Ø§Ù„Ø´Ù‡Ø± (ÙŠÙ†Ø§ÙŠØ±ØŒ ÙØ¨Ø±Ø§ÙŠØ±ØŒ Ø¥Ù„Ø®)
        break;
      default:
        startDate = subDays(today, 7);
        format_pattern = 'dd/MM';
    }
    
    const startDateStr = format(startDate, 'yyyy-MM-dd');
    const endDateStr = format(endDate, 'yyyy-MM-dd');
    
    const salesData = await this.getDailySalesByBranchAndDateRange(branchId, startDateStr, endDateStr);
    
    // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const salesByDate = new Map();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙˆØ§Ø±ÙŠØ® ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚
    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
      const dateKey = format(currentDate, 'yyyy-MM-dd');
      const formattedDate = format(currentDate, format_pattern, { locale: ar });
      
      salesByDate.set(dateKey, {
        date: formattedDate,
        cashSales: 0,
        networkSales: 0,
        totalSales: 0,
        target: 0
      });
      
      currentDate = addDays(currentDate, 1);
    }
    
    // Ù…Ù„Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙØ¹Ù„ÙŠØ©
    for (const sale of salesData) {
      const dateKey = format(new Date(sale.date), 'yyyy-MM-dd');
      
      if (salesByDate.has(dateKey)) {
        const currentData = salesByDate.get(dateKey);
        
        currentData.cashSales += sale.totalCashSales;
        
        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
        if (typeof sale.totalNetworkSales !== 'undefined') {
          currentData.networkSales += sale.totalNetworkSales;
        } else {
          // Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø¯ÙŠÙ… - Ù†Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ…Ø© ØµÙØ±
          currentData.networkSales += 0;
        }
        
        currentData.totalSales += sale.totalSales;
      }
    }
    
    // Ø¥Ø¶Ø§ÙØ© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ø¯Ù
    const month = today.getMonth() + 1;
    const year = today.getFullYear();
    const monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, month, year);
    
    if (monthlyTarget) {
      const daysInMonth = new Date(year, month, 0).getDate();
      const dailyTarget = monthlyTarget.targetAmount / daysInMonth;
      
      for (const [dateKey, data] of salesByDate.entries()) {
        data.target = dailyTarget;
      }
    }
    
    return Array.from(salesByDate.values());
  }

  async getConsolidatedDailySales(): Promise<ConsolidatedDailySales[]> {
    return db.select().from(consolidatedDailySales);
  }

  async getConsolidatedDailySalesByBranch(branchId: number): Promise<ConsolidatedDailySales[]> {
    return db
      .select()
      .from(consolidatedDailySales)
      .where(eq(consolidatedDailySales.branchId, branchId))
      .orderBy(desc(consolidatedDailySales.date)); // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
  }

  async getConsolidatedDailySalesByDate(date: string): Promise<ConsolidatedDailySales[]> {
    return db
      .select()
      .from(consolidatedDailySales)
      .where(eq(consolidatedDailySales.date, date))
      .orderBy(consolidatedDailySales.branchId); // ØªØ±ØªÙŠØ¨ ØªØµØ§Ø¹Ø¯ÙŠ Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹
  }

  async getConsolidatedDailySalesById(id: number): Promise<ConsolidatedDailySales | undefined> {
    const result = await db
      .select()
      .from(consolidatedDailySales)
      .where(eq(consolidatedDailySales.id, id));
    
    return result[0];
  }

  async createConsolidatedDailySales(sales: InsertConsolidatedDailySales): Promise<ConsolidatedDailySales> {
    const [newSale] = await db.insert(consolidatedDailySales).values(sales).returning();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø¥Ù†Ø´Ø§Ø¡ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø©
    await this.createActivity({
      userId: sales.createdBy,
      branchId: sales.branchId,
      action: 'create_consolidated_sales',
      details: {
        date: sales.date,
        totalSales: sales.totalSales
      }
    });
    
    return newSale;
  }

  async closeConsolidatedDailySales(id: number, userId: number): Promise<ConsolidatedDailySales | undefined> {
    const [updatedSale] = await db
      .update(consolidatedDailySales)
      .set({ 
        status: 'closed',
        closedBy: userId,
        closedAt: new Date()
      })
      .where(eq(consolidatedDailySales.id, id))
      .returning();
    
    if (updatedSale) {
      // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø´Ø§Ø· Ù„ØªØªØ¨Ø¹ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
      await this.createActivity({
        userId,
        branchId: updatedSale.branchId,
        action: 'close_consolidated_sales',
        details: {
          id: updatedSale.id,
          date: updatedSale.date,
          totalSales: updatedSale.totalSales
        }
      });
    }
    
    return updatedSale;
  }

  async consolidateDailySales(branchId: number, date: string, userId: number): Promise<ConsolidatedDailySales | undefined> {
    // 1. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø³Ø¬Ù„Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„ÙØ±Ø¹ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
    const dailySalesRecords = await this.getDailySalesByBranchAndDate(branchId, date);
    
    if (dailySalesRecords.length === 0) {
      return undefined;
    }
    
    // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø© Ø³Ø§Ø¨Ù‚Ø© Ù„Ù†ÙØ³ Ø§Ù„ÙØ±Ø¹ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
    const existingConsolidated = await db
      .select()
      .from(consolidatedDailySales)
      .where(
        and(
          eq(consolidatedDailySales.branchId, branchId),
          eq(consolidatedDailySales.date, date)
        )
      );
    
    // 3. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ§Øª
    let totalCashSales = 0;
    let totalNetworkSales = 0;
    let totalSales = 0;
    let totalTransactions = 0;
    let totalDiscrepancy = 0;
    
    dailySalesRecords.forEach(sale => {
      totalCashSales += sale.totalCashSales || 0;
      totalNetworkSales += sale.totalNetworkSales || 0;
      totalSales += sale.totalSales || 0;
      totalTransactions += sale.totalTransactions || 0;
      if (sale.discrepancy) {
        totalDiscrepancy += sale.discrepancy;
      }
    });
    
    // 4. Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ§ØªÙˆØ±Ø©
    const averageTicket = totalTransactions > 0 ? totalSales / totalTransactions : 0;
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ ÙŠÙˆÙ…ÙŠØ© Ù…Ø¬Ù…Ø¹Ø© Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ«Ù‡Ø§
    if (existingConsolidated.length > 0) {
      const [updatedSale] = await db
        .update(consolidatedDailySales)
        .set({
          totalCashSales,
          totalNetworkSales,
          totalSales,
          totalTransactions,
          averageTicket,
          totalDiscrepancy
        })
        .where(eq(consolidatedDailySales.id, existingConsolidated[0].id))
        .returning();
      
      // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
      for (const sale of dailySalesRecords) {
        if (sale.status !== 'transferred') {
          await this.updateDailySalesStatus(sale.id, 'transferred', updatedSale.id);
        }
      }
      
      return updatedSale;
    }
    
    // 5. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙŠÙˆÙ…ÙŠØ© Ø§Ù„Ù…Ø¬Ù…Ø¹Ø©
    const consolidatedSale = await this.createConsolidatedDailySales({
      branchId,
      date,
      totalCashSales,
      totalNetworkSales,
      totalSales,
      totalTransactions,
      averageTicket,
      totalDiscrepancy,
      status: 'open',
      createdBy: userId
    });
    
    // 6. ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    for (const sale of dailySalesRecords) {
      await this.updateDailySalesStatus(sale.id, 'transferred', consolidatedSale.id);
    }
    
    return consolidatedSale;
  }

  async initializeDemoData(): Promise<void> {
    // ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„
    const [userCount] = await db.select({ count: sql`count(*)` }).from(users);
    
    if (userCount.count > 0) {
      console.log("Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ØŒ ØªØ®Ø·ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©");
      return;
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„
    await this.createUser({
      username: "admin",
      password: "admin123",
      name: "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯",
      role: "admin",
      email: "admin@butterbakery.com",
      avatar: "https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=80&q=80",
      isActive: true
    });
    
    // ...Ø¨Ø§Ù‚ÙŠ Ø´ÙŠÙØ±Ø© Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ© ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ
  }

  // ==== ÙˆØ¸Ø§Ø¦Ù Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª ÙˆØ§Ù„Ø­ÙˆØ§ÙØ² ====
  
  // Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getUserRewardPoints(userId: number): Promise<RewardPoints | undefined> {
    const result = await db.query.rewardPoints.findFirst({
      where: eq(rewardPoints.userId, userId)
    });
    return result;
  }
  
  async updateUserRewardPoints(userId: number, points: number): Promise<RewardPoints | undefined> {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    let userPoints = await this.getUserRewardPoints(userId);
    
    // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ù†Ù‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§
    if (!userPoints) {
      const newUserPoints = await db.insert(rewardPoints).values({
        userId,
        points: 0,
        availablePoints: 0,
        totalEarnedPoints: 0,
        lastUpdated: new Date()
      }).returning();
      
      userPoints = newUserPoints[0];
    }
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ù‚Ø§Ø·
    const updatedPoints = await db.update(rewardPoints)
      .set({
        points: userPoints.points + points,
        availablePoints: userPoints.availablePoints + (points > 0 ? points : 0), // Ù†Ø¶ÙŠÙ ÙÙ‚Ø· Ù„Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ØªØ§Ø­Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¥Ø¶Ø§ÙØ© ÙˆÙ„ÙŠØ³Øª Ø®ØµÙ…
        totalEarnedPoints: userPoints.totalEarnedPoints + (points > 0 ? points : 0), // Ù†Ø¶ÙŠÙ ÙÙ‚Ø· Ù„Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØªØ³Ø¨Ø© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¥Ø¶Ø§ÙØ©
        lastUpdated: new Date()
      })
      .where(eq(rewardPoints.id, userPoints.id))
      .returning();
    
    return updatedPoints[0];
  }
  
  async addRewardPointsHistory(history: InsertRewardPointsHistory): Promise<RewardPointsHistory> {
    const result = await db.insert(rewardPointsHistory).values(history).returning();
    
    // ØªØ­Ø¯ÙŠØ« Ø±ØµÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await this.updateUserRewardPoints(history.userId, history.points);
    
    return result[0];
  }
  
  async getRewardPointsHistory(userId: number, limit?: number): Promise<RewardPointsHistory[]> {
    const query = db.select().from(rewardPointsHistory)
      .where(eq(rewardPointsHistory.userId, userId))
      .orderBy(desc(rewardPointsHistory.timestamp));
    
    if (limit) {
      query.limit(limit);
    }
    
    return await query;
  }
  
  async getRewardPointsHistoryByType(userId: number, type: string): Promise<RewardPointsHistory[]> {
    return await db.select().from(rewardPointsHistory)
      .where(and(
        eq(rewardPointsHistory.userId, userId),
        eq(rewardPointsHistory.type, type)
      ))
      .orderBy(desc(rewardPointsHistory.timestamp));
  }
  
  // Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²Ø§Øª
  async getAllAchievements(): Promise<Achievement[]> {
    return await db.select().from(achievements)
      .where(eq(achievements.isActive, true))
      .orderBy(achievements.name);
  }
  
  async getAchievement(id: number): Promise<Achievement | undefined> {
    return await db.query.achievements.findFirst({
      where: eq(achievements.id, id)
    });
  }
  
  async getAchievementsByCategory(category: string): Promise<Achievement[]> {
    return await db.select().from(achievements)
      .where(and(
        eq(achievements.category, category),
        eq(achievements.isActive, true)
      ))
      .orderBy(achievements.name);
  }
  
  async createAchievement(achievement: InsertAchievement): Promise<Achievement> {
    const result = await db.insert(achievements).values(achievement).returning();
    return result[0];
  }
  
  async updateAchievement(id: number, achievement: Partial<Achievement>): Promise<Achievement | undefined> {
    const result = await db.update(achievements)
      .set(achievement)
      .where(eq(achievements.id, id))
      .returning();
    
    return result[0];
  }
  
  // Ø¥Ù†Ø¬Ø§Ø²Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  async getUserAchievements(userId: number): Promise<UserAchievement[]> {
    return await db.select().from(userAchievements)
      .where(eq(userAchievements.userId, userId))
      .orderBy(userAchievements.awardedAt);
  }
  
  async assignAchievementToUser(userAchievement: InsertUserAchievement): Promise<UserAchievement> {
    const result = await db.insert(userAchievements).values({
      ...userAchievement,
      awardedAt: new Date(),
      isCompleted: false
    }).returning();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const achievement = await this.getAchievement(userAchievement.achievementId);
    if (achievement) {
      await this.createNotification({
        userId: userAchievement.userId,
        title: "Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯ Ù…ØªØ§Ø­!",
        message: `ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø¥Ù†Ø¬Ø§Ø² Ø¬Ø¯ÙŠØ¯: ${achievement.name}. Ø§ÙƒØªØ´Ù ÙƒÙŠÙÙŠØ© ØªØ­Ù‚ÙŠÙ‚Ù‡!`,
        type: "info",
        timestamp: new Date(),
        link: "/achievements"
      });
    }
    
    return result[0];
  }
  
  async updateUserAchievementProgress(userId: number, achievementId: number, progress: number): Promise<UserAchievement | undefined> {
    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const userAchievement = await db.query.userAchievements.findFirst({
      where: and(
        eq(userAchievements.userId, userId),
        eq(userAchievements.achievementId, achievementId)
      )
    });
    
    if (!userAchievement) return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚Ø¯Ù…
    const newProgress = Math.min(Math.max(progress, 0), 100); // Ø¶Ù…Ø§Ù† Ø£Ù† Ø§Ù„ØªÙ‚Ø¯Ù… Ø¨ÙŠÙ† 0 Ùˆ 100
    const updates: Partial<UserAchievement> = { progress: newProgress };
    
    // Ø¥Ø°Ø§ ÙˆØµÙ„ Ø§Ù„ØªÙ‚Ø¯Ù… Ø¥Ù„Ù‰ 100%ØŒ Ù†Ø¹ØªØ¨Ø±Ù‡ Ù…ÙƒØªÙ…Ù„Ø§Ù‹
    if (newProgress >= 100 && !userAchievement.isCompleted) {
      updates.isCompleted = true;
      updates.completedAt = new Date();
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø·
      const achievement = await this.getAchievement(achievementId);
      if (achievement) {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await this.addRewardPointsHistory({
          userId,
          points: achievement.pointsValue,
          type: "earned",
          reason: `ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø¥Ù†Ø¬Ø§Ø²: ${achievement.name}`,
          relatedEntityType: "achievement",
          relatedEntityId: achievementId,
          date: new Date(),
          timestamp: new Date(),
          status: "active",
          branchId: null
        });
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¨ØªØ­Ù‚ÙŠÙ‚ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
        await this.createNotification({
          userId,
          title: "ğŸ‰ ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø¥Ù†Ø¬Ø§Ø²",
          message: `Ù„Ù‚Ø¯ Ø­Ù‚Ù‚Øª Ø¥Ù†Ø¬Ø§Ø² "${achievement.name}" ÙˆÙƒØ³Ø¨Øª ${achievement.pointsValue} Ù†Ù‚Ø·Ø©!`,
          type: "success",
          timestamp: new Date(),
          link: "/achievements"
        });
      }
    }
    
    const result = await db.update(userAchievements)
      .set(updates)
      .where(eq(userAchievements.id, userAchievement.id))
      .returning();
    
    return result[0];
  }
  
  async completeUserAchievement(userId: number, achievementId: number): Promise<UserAchievement | undefined> {
    return this.updateUserAchievementProgress(userId, achievementId, 100);
  }
  
  // Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getAllRewards(): Promise<Reward[]> {
    return await db.select().from(rewards)
      .where(eq(rewards.isActive, true))
      .orderBy(rewards.pointsCost);
  }
  
  async getReward(id: number): Promise<Reward | undefined> {
    return await db.query.rewards.findFirst({
      where: eq(rewards.id, id)
    });
  }
  
  async getRewardsByCategory(category: string): Promise<Reward[]> {
    return await db.select().from(rewards)
      .where(and(
        eq(rewards.category, category),
        eq(rewards.isActive, true)
      ))
      .orderBy(rewards.pointsCost);
  }
  
  async createReward(reward: InsertReward): Promise<Reward> {
    const result = await db.insert(rewards).values(reward).returning();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹ Ø¨Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    await this.createNotification({
      userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
      title: "Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…ØªØ§Ø­Ø©!",
      message: `ØªÙ… Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯Ø©: ${reward.name}. ØªÙƒÙ„ÙØ©: ${reward.pointsCost} Ù†Ù‚Ø·Ø©.`,
      type: "info",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return result[0];
  }
  
  async updateReward(id: number, reward: Partial<Reward>): Promise<Reward | undefined> {
    const result = await db.update(rewards)
      .set(reward)
      .where(eq(rewards.id, id))
      .returning();
    
    return result[0];
  }
  
  // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ¢Øª
  async getUserRedemptions(userId: number): Promise<RewardRedemption[]> {
    return await db.select().from(rewardRedemptions)
      .where(eq(rewardRedemptions.userId, userId))
      .orderBy(desc(rewardRedemptions.redeemedAt));
  }
  
  async createRedemption(redemption: InsertRewardRedemption): Promise<RewardRedemption> {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø¯ÙŠÙ‡ Ù†Ù‚Ø§Ø· ÙƒØ§ÙÙŠØ©
    const userPoints = await this.getUserRewardPoints(redemption.userId);
    const reward = await this.getReward(redemption.rewardId);
    
    if (!userPoints || !reward) {
      throw new Error("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
    }
    
    if (userPoints.availablePoints < redemption.pointsUsed) {
      throw new Error("Ø§Ù„Ù†Ù‚Ø§Ø· ØºÙŠØ± ÙƒØ§ÙÙŠØ© Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©");
    }
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const result = await db.insert(rewardRedemptions).values({
      ...redemption,
      redeemedAt: new Date(),
      status: "pending"
    }).returning();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† Ø¨Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯
    await this.createNotification({
      userId: null, // Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†
      title: "Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© Ø¬Ø¯ÙŠØ¯",
      message: `Ù‚Ø§Ù… Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø±Ù‚Ù… ${redemption.userId} Ø¨Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}".`,
      type: "info",
      timestamp: new Date(),
      link: "/redemptions"
    });
    
    return result[0];
  }
  
  async approveRedemption(id: number, approverId: number): Promise<RewardRedemption | undefined> {
    const redemption = await db.query.rewardRedemptions.findFirst({
      where: eq(rewardRedemptions.id, id)
    });
    
    if (!redemption || redemption.status !== "pending") return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const result = await db.update(rewardRedemptions)
      .set({
        status: "approved",
        approvedBy: approverId,
        approvedAt: new Date()
      })
      .where(eq(rewardRedemptions.id, id))
      .returning();
    
    if (result.length === 0) return undefined;
    
    // Ø®ØµÙ… Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ù† Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    await this.addRewardPointsHistory({
      userId: redemption.userId,
      points: -redemption.pointsUsed, // Ù‚ÙŠÙ…Ø© Ø³Ø§Ù„Ø¨Ø© Ù„Ù„Ø®ØµÙ…
      type: "redeemed",
      reason: `Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© Ø¨Ù…Ø¹Ø±Ù ${redemption.rewardId}`,
      relatedEntityType: "redemption",
      relatedEntityId: redemption.id,
      date: new Date(),
      timestamp: new Date(),
      status: "active",
      branchId: null
    });
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ÙÙŠ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
    const reward = await this.getReward(redemption.rewardId);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    await this.createNotification({
      userId: redemption.userId,
      title: "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
      message: reward 
        ? `ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}".` 
        : "ØªÙ…Øª Ø§Ù„Ù…ÙˆØ§ÙÙ‚Ø© Ø¹Ù„Ù‰ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©.",
      type: "success",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return result[0];
  }
  
  async rejectRedemption(id: number, notes?: string): Promise<RewardRedemption | undefined> {
    const redemption = await db.query.rewardRedemptions.findFirst({
      where: eq(rewardRedemptions.id, id)
    });
    
    if (!redemption || redemption.status !== "pending") return undefined;
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    const result = await db.update(rewardRedemptions)
      .set({
        status: "rejected",
        notes: notes || redemption.notes
      })
      .where(eq(rewardRedemptions.id, id))
      .returning();
    
    if (result.length === 0) return undefined;
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ù„Ø¥Ø¶Ø§ÙØªÙ‡Ø§ ÙÙŠ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±
    const reward = await this.getReward(redemption.rewardId);
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„
    await this.createNotification({
      userId: redemption.userId,
      title: "ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø§Ø³ØªØ¨Ø¯Ø§Ù„",
      message: reward
        ? `ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù…ÙƒØ§ÙØ£Ø© "${reward.name}". ${notes ? `Ø§Ù„Ø³Ø¨Ø¨: ${notes}` : ''}`
        : `ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©. ${notes ? `Ø§Ù„Ø³Ø¨Ø¨: ${notes}` : ''}`,
      type: "error",
      timestamp: new Date(),
      link: "/rewards"
    });
    
    return result[0];
  }
  
  async getRedemptionsByStatus(status: string): Promise<RewardRedemption[]> {
    return await db.select().from(rewardRedemptions)
      .where(eq(rewardRedemptions.status, status))
      .orderBy(rewardRedemptions.redeemedAt);
  }
  
  // Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†
  async getActiveLeaderboards(): Promise<Leaderboard[]> {
    return await db.select().from(leaderboards)
      .where(eq(leaderboards.isActive, true))
      .orderBy(leaderboards.endDate);
  }
  
  async getLeaderboard(id: number): Promise<Leaderboard | undefined> {
    return await db.query.leaderboards.findFirst({
      where: eq(leaderboards.id, id)
    });
  }
  
  async createLeaderboard(leaderboard: InsertLeaderboard): Promise<Leaderboard> {
    const result = await db.insert(leaderboards).values({
      ...leaderboard,
      createdAt: new Date()
    }).returning();
    
    // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¬Ù…ÙŠØ¹ Ø¨Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    await this.createNotification({
      userId: null, // Ù„Ù„Ø¬Ù…ÙŠØ¹
      title: "Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯Ø© Ù…ØªØ§Ø­Ø©!",
      message: `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ØªØµØ¯Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯Ø©: "${leaderboard.name}". ØªØ¨Ø¯Ø£ Ù…Ù† ${new Date(leaderboard.startDate).toLocaleDateString('ar-SA')}.`,
      type: "info",
      timestamp: new Date(),
      link: "/leaderboards"
    });
    
    return result[0];
  }
  
  async updateLeaderboardResults(leaderboardId: number, results: InsertLeaderboardResult[]): Promise<LeaderboardResult[]> {
    const updatedResults: LeaderboardResult[] = [];
    
    for (const result of results) {
      const existingResult = await db.query.leaderboardResults.findFirst({
        where: and(
          eq(leaderboardResults.leaderboardId, leaderboardId),
          eq(leaderboardResults.userId, result.userId)
        )
      });
      
      // ØªØ­ÙˆÙŠÙ„ score Ùˆ metricValue Ø¥Ù„Ù‰ Ù†Øµ Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ù†ÙˆØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
      const formattedResult = {
        ...result,
        score: result.score.toString(),
        metricValue: result.metricValue.toString()
      };
      
      let currentResult;
      
      if (existingResult) {
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
        const updated = await db.update(leaderboardResults)
          .set({
            ...formattedResult,
            updateDate: new Date()
          })
          .where(eq(leaderboardResults.id, existingResult.id))
          .returning();
        
        currentResult = updated[0];
      } else {
        // Ø¥Ù†Ø´Ø§Ø¡ Ù†ØªÙŠØ¬Ø© Ø¬Ø¯ÙŠØ¯Ø©
        const inserted = await db.insert(leaderboardResults).values({
          ...formattedResult,
          leaderboardId,
          updateDate: new Date()
        }).returning();
        
        currentResult = inserted[0];
      }
      
      updatedResults.push(currentResult);
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø±ÙƒØ² ÙÙŠ Ø§Ù„Ù…Ø±Ø§ÙƒØ² Ø§Ù„Ø«Ù„Ø§Ø«Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ØŒ Ù†Ø±Ø³Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Ù‹ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…
      if (result.rank <= 3) {
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù„ÙˆØ­Ø©
        const leaderboard = await this.getLeaderboard(leaderboardId);
        if (leaderboard) {
          let rankText = "";
          if (result.rank === 1) rankText = "Ø§Ù„Ø£ÙˆÙ„ ğŸ¥‡";
          else if (result.rank === 2) rankText = "Ø§Ù„Ø«Ø§Ù†ÙŠ ğŸ¥ˆ";
          else if (result.rank === 3) rankText = "Ø§Ù„Ø«Ø§Ù„Ø« ğŸ¥‰";
          
          await this.createNotification({
            userId: result.userId,
            title: "ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! Ø£Ù†Øª Ù…Ù† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†",
            message: `Ù„Ù‚Ø¯ Ø­ØµÙ„Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±ÙƒØ² ${rankText} ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ† "${leaderboard.name}".`,
            type: "success",
            timestamp: new Date(),
            link: "/leaderboards"
          });
        }
      }
    }
    
    return updatedResults;
  }
  
  async getLeaderboardResults(leaderboardId: number): Promise<LeaderboardResult[]> {
    return await db.select().from(leaderboardResults)
      .where(eq(leaderboardResults.leaderboardId, leaderboardId))
      .orderBy(leaderboardResults.rank);
  }
  
  async getUserLeaderboardRank(leaderboardId: number, userId: number): Promise<LeaderboardResult | undefined> {
    return await db.query.leaderboardResults.findFirst({
      where: and(
        eq(leaderboardResults.leaderboardId, leaderboardId),
        eq(leaderboardResults.userId, userId)
      )
    });
  }
  
  // ÙˆØ¸Ø§Ø¦Ù ØªØ­Ù„ÙŠÙ„ Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  async analyzeSalesDrops(branchId: number, period: string): Promise<any> {
    const today = new Date();
    let startDate = new Date();
    let endDate = new Date();
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„ØªØ­Ù„ÙŠÙ„
    if (period === 'week') {
      // Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    } else if (period === 'month') {
      // Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
    } else if (period === 'quarter') {
      // Ø§Ù„Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
      startDate = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    } else {
      // Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹: Ø¢Ø®Ø± Ø£Ø³Ø¨ÙˆØ¹
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    }
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ø© Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©
    const formattedStartDate = format(startDate, 'yyyy-MM-dd');
    const formattedEndDate = format(endDate, 'yyyy-MM-dd');
    
    const sales = await this.getDailySalesByBranchAndDateRange(
      branchId, 
      formattedStartDate, 
      formattedEndDate
    );
    
    // ØªÙ†Ø¸ÙŠÙ… Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ÙŠÙˆÙ…
    const salesByDay: { [key: string]: { total: number, count: number, average: number, date: string } } = {};
    
    for (const sale of sales) {
      const dateStr = sale.date;
      if (!salesByDay[dateStr]) {
        salesByDay[dateStr] = { total: 0, count: 0, average: 0, date: dateStr };
      }
      
      salesByDay[dateStr].total += sale.totalSales;
      salesByDay[dateStr].count += 1;
    }
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„ÙŠÙˆÙ…ÙŠ
    for (const day in salesByDay) {
      salesByDay[day].average = salesByDay[day].total / salesByDay[day].count;
    }
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù„ÙØªØ±Ø© ÙƒØ§Ù…Ù„Ø©
    const dailyTotals = Object.values(salesByDay).map(day => day.total);
    const overallAverage = dailyTotals.reduce((sum, total) => sum + total, 0) / dailyTotals.length || 0;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠØ§Ù… Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (Ø£Ù‚Ù„ Ù…Ù† 70% Ù…Ù† Ø§Ù„Ù…ØªÙˆØ³Ø·)
    const dropThreshold = overallAverage * 0.7;
    const salesDrops = Object.values(salesByDay)
      .filter(day => day.total < dropThreshold)
      .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„ØªÙˆØµÙŠØ§Øª
    const analysis = {
      totalDays: Object.keys(salesByDay).length,
      dropDays: salesDrops.length,
      dropPercentage: (salesDrops.length / Object.keys(salesByDay).length) * 100,
      worstDay: salesDrops.length > 0 ? 
        salesDrops.reduce((worst, current) => current.total < worst.total ? current : worst, salesDrops[0]) : 
        null,
      consecutiveDrops: this.checkForConsecutiveDrops(salesDrops),
      weekdayPattern: this.checkForWeekdayPattern(salesDrops),
      recommendations: this.generateDropRecommendations(salesDrops, overallAverage)
    };
    
    return {
      period,
      overallAverage,
      dropThreshold,
      salesDrops,
      salesByDay: Object.values(salesByDay),
      analysis
    };
  }
  
  // ØªÙˆÙ„ÙŠØ¯ ØªÙˆØµÙŠØ§Øª Ù„Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
  private generateDropRecommendations(salesDrops: any[], average: number): any[] {
    if (salesDrops.length === 0) return [];
    
    const recommendations = [];
    
    // ÙØ­Øµ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: Ù‡Ù„ Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ©ØŸ
    const consecutiveDrops = this.checkForConsecutiveDrops(salesDrops);
    if (consecutiveDrops.isConsecutive) {
      recommendations.push({
        type: 'warning',
        title: 'Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `Ù„ÙˆØ­Ø¸ Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù…Ø¯Ø© ${consecutiveDrops.days} Ø£ÙŠØ§Ù… Ù…ØªØªØ§Ù„ÙŠØ©.`,
        actions: [
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªØ³Ø¹ÙŠØ±',
          'ØªØ®Ø·ÙŠØ· Ø­Ù…Ù„Ø© ØªØ±ÙˆÙŠØ¬ÙŠØ© Ø¹Ø§Ø¬Ù„Ø©',
          'ØªØ­Ù„ÙŠÙ„ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…Ù†Ø§ÙØ³ÙŠÙ†'
        ]
      });
    }
    
    // ÙØ­Øµ Ø§Ù„Ù…ÙˆØ³Ù…ÙŠØ©: Ù‡Ù„ Ø£ÙŠØ§Ù… Ù…Ø­Ø¯Ø¯Ø© Ù…Ù† Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…ØªÙƒØ±Ø±Ø© ÙÙŠ Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶Ø§ØªØŸ
    const weekdayPattern = this.checkForWeekdayPattern(salesDrops);
    if (weekdayPattern.hasPattern) {
      recommendations.push({
        type: 'insight',
        title: 'Ù†Ù…Ø· Ø£Ø³Ø¨ÙˆØ¹ÙŠ ÙÙŠ Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `ÙŠÙˆØ¬Ø¯ Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ù†ØªØ¸Ù… ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ Ø£ÙŠØ§Ù… ${weekdayPattern.days.join(', ')}.`,
        actions: [
          'ØªØ®Ø·ÙŠØ· Ø¹Ø±ÙˆØ¶ Ø®Ø§ØµØ© ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙŠØ§Ù…',
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø£ÙŠØ§Ù…',
          'Ø¯Ø±Ø§Ø³Ø© Ø£Ù†Ù…Ø§Ø· Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡'
        ]
      });
    }
    
    // ÙØ­Øµ Ø´Ø¯Ø© Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶: Ù‡Ù„ Ù‡Ù†Ø§Ùƒ Ø£ÙŠØ§Ù… Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø´Ø¯ÙŠØ¯ØŸ
    const severeDrops = salesDrops.filter(day => day.total < (average * 0.5));
    if (severeDrops.length > 0) {
      recommendations.push({
        type: 'critical',
        title: 'Ø§Ù†Ø®ÙØ§Ø¶ Ø­Ø§Ø¯ ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª',
        message: `Ù‡Ù†Ø§Ùƒ ${severeDrops.length} Ø£ÙŠØ§Ù… Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø´Ø¯ÙŠØ¯ ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (Ø£Ù‚Ù„ Ù…Ù† 50% Ù…Ù† Ø§Ù„Ù…ØªÙˆØ³Ø·).`,
        actions: [
          'Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© (Ø§Ù„Ø·Ù‚Ø³ØŒ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø­Ù„ÙŠØ©)',
          'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ§Ù„Ø®Ø¯Ù…Ø©',
          'Ø¥Ø·Ù„Ø§Ù‚ Ø®ØµÙˆÙ…Ø§Øª Ù…Ø³ØªÙ‡Ø¯ÙØ©'
        ]
      });
    }
    
    // Ø¥Ø¶Ø§ÙØ© ØªÙˆØµÙŠØ§Øª Ø¹Ø§Ù…Ø©
    recommendations.push({
      type: 'general',
      title: 'ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…',
      message: 'ØªÙˆØµÙŠØ§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù… Ù„Ù„Ù…Ø¨ÙŠØ¹Ø§Øª.',
      actions: [
        'Ù…Ø±Ø§Ø¬Ø¹Ø© ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ø´Ø§Ù…Ù„Ø©',
        'ØªØ¯Ø±ÙŠØ¨ ÙØ±ÙŠÙ‚ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø¹Ù„Ù‰ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„ÙØ¹Ø§Ù„Ø©',
        'ØªØ­Ù„ÙŠÙ„ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ø³ÙˆÙ‚'
      ]
    });
    
    return recommendations;
  }
  
  // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ø§Ù†Ø®ÙØ§Ø¶Ø§Øª Ù…ØªØªØ§Ù„ÙŠØ©
  private checkForConsecutiveDrops(salesDrops: any[]): { isConsecutive: boolean, days: number } {
    if (salesDrops.length < 2) return { isConsecutive: false, days: 0 };
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£ÙŠØ§Ù… Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const sortedDrops = [...salesDrops].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    let maxConsecutive = 1;
    let currentConsecutive = 1;
    
    for (let i = 1; i < sortedDrops.length; i++) {
      const prevDate = new Date(sortedDrops[i-1].date);
      const currDate = new Date(sortedDrops[i].date);
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ÙŠÙˆÙ… Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¨Ø§Ø´Ø±Ø©
      const diffTime = Math.abs(currDate.getTime() - prevDate.getTime());
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      if (diffDays === 1) {
        currentConsecutive++;
        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
      } else {
        currentConsecutive = 1;
      }
    }
    
    return { isConsecutive: maxConsecutive >= 3, days: maxConsecutive };
  }
  
  // ÙØ­Øµ ÙˆØ¬ÙˆØ¯ Ù†Ù…Ø· ÙÙŠ Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
  private checkForWeekdayPattern(salesDrops: any[]): { hasPattern: boolean, days: string[] } {
    if (salesDrops.length < 3) return { hasPattern: false, days: [] };
    
    // Ø¹Ø¯ ØªÙƒØ±Ø§Ø± ÙƒÙ„ ÙŠÙˆÙ… Ù…Ù† Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
    const weekdayCounts: Record<string, number> = {
      'Ø§Ù„Ø£Ø­Ø¯': 0, 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†': 0, 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡': 0, 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡': 0, 'Ø§Ù„Ø®Ù…ÙŠØ³': 0, 'Ø§Ù„Ø¬Ù…Ø¹Ø©': 0, 'Ø§Ù„Ø³Ø¨Øª': 0
    };
    
    const arabicDays = ['Ø§Ù„Ø£Ø­Ø¯', 'Ø§Ù„Ø§Ø«Ù†ÙŠÙ†', 'Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡', 'Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡', 'Ø§Ù„Ø®Ù…ÙŠØ³', 'Ø§Ù„Ø¬Ù…Ø¹Ø©', 'Ø§Ù„Ø³Ø¨Øª'];
    
    for (const drop of salesDrops) {
      const date = new Date(drop.date);
      const dayOfWeek = date.getDay();
      weekdayCounts[arabicDays[dayOfWeek]]++;
    }
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù†Ù…Ø· (ØªÙƒØ±Ø§Ø± Ù„Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø©)
    const patternDays = Object.entries(weekdayCounts)
      .filter(([_, count]) => count >= 2)
      .map(([day, _]) => day);
    
    return { hasPattern: patternDays.length > 0, days: patternDays };
  }
  
  async generateSalesAlerts(branchId: number, threshold: number): Promise<any[]> {
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„Ù„Ø£Ø³Ø¨ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¶ÙŠ
    const today = new Date();
    const oneWeekAgo = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    
    const formattedStartDate = format(oneWeekAgo, 'yyyy-MM-dd');
    const formattedEndDate = format(today, 'yyyy-MM-dd');
    
    const sales = await this.getDailySalesByBranchAndDateRange(
      branchId,
      formattedStartDate,
      formattedEndDate
    );
    
    if (sales.length === 0) return [];
    
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø­Ø¯Ø« Ù‡Ø¯Ù Ø´Ù‡Ø±ÙŠ
    const currentMonth = today.getMonth() + 1;
    const currentYear = today.getFullYear();
    const monthlyTarget = await this.getMonthlyTargetByBranchAndDate(branchId, currentMonth, currentYear);
    
    if (!monthlyTarget) return [];
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©
    const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
    const avgDailySales = totalSales / sales.length;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ (ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø´Ù‡Ø±ÙŠ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø£ÙŠØ§Ù… Ø§Ù„Ø´Ù‡Ø±)
    const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
    const dailyTarget = monthlyTarget.targetAmount / daysInMonth;
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ù‡Ø¯Ù
    const alerts = [];
    
    if (avgDailySales < (dailyTarget * (threshold / 100))) {
      // Ø¥Ù†Ø´Ø§Ø¡ ØªÙ†Ø¨ÙŠÙ‡ Ø¨Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
      const percentageOfTarget = (avgDailySales / dailyTarget) * 100;
      
      const branch = await this.getBranch(branchId);
      const branchName = branch ? branch.name : `ÙØ±Ø¹ #${branchId}`;
      
      alerts.push({
        id: `sales-drop-${Date.now()}`,
        branchId,
        branchName,
        date: format(today, 'yyyy-MM-dd'),
        severity: percentageOfTarget < 50 ? 'critical' : percentageOfTarget < 70 ? 'high' : 'medium',
        type: 'sales_drop',
        metric: {
          current: avgDailySales,
          expected: dailyTarget,
          difference: dailyTarget - avgDailySales,
          percentageChange: ((dailyTarget - avgDailySales) / dailyTarget) * 100
        },
        recommendations: [
          {
            id: "rec1",
            text: "Ø¥Ø¬Ø±Ø§Ø¡ ØªØ®ÙÙŠØ¶Ø§Øª Ù…Ø¤Ù‚ØªØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø£ÙƒØ«Ø± Ù…Ø¨ÙŠØ¹Ø§Ù‹",
            priority: "high",
            impact: 80
          },
          {
            id: "rec2",
            text: "ØªÙ†Ø´ÙŠØ· Ø­Ù…Ù„Ø© ØªØ³ÙˆÙŠÙ‚ Ø¹Ù„Ù‰ ÙˆØ³Ø§Ø¦Ù„ Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ",
            priority: "medium",
            impact: 65
          },
          {
            id: "rec3",
            text: "Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¬Ø¯ÙˆÙ„ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ÙˆØ¸ÙÙŠÙ† Ù„Ø¶Ù…Ø§Ù† ØªØºØ·ÙŠØ© Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø°Ø±ÙˆØ©",
            priority: "medium",
            impact: 60
          }
        ],
        details: `Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠ (${avgDailySales.toFixed(2)}) Ø£Ù‚Ù„ Ù…Ù† ${threshold}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ (${dailyTarget.toFixed(2)})`
      });
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø´Ø¹Ø§Ø± Ø¨Ø§Ù„Ø§Ù†Ø®ÙØ§Ø¶
      await this.createNotification({
        userId: null, // Ù„Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ†
        title: "âš ï¸ ØªÙ†Ø¨ÙŠÙ‡: Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª",
        message: `Ø§Ù†Ø®ÙØ§Ø¶ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ${branchName} Ø¥Ù„Ù‰ ${percentageOfTarget.toFixed(1)}% Ù…Ù† Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙŠÙˆÙ…ÙŠ.`,
        type: "warning",
        timestamp: new Date(),
        link: "/smart-alerts"
      });
    }
    
    return alerts;
  }
  
  async analyzeCashierPerformanceTrends(branchId: number, period: string): Promise<any[]> {
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† ÙÙŠ Ø§Ù„ÙØ±Ø¹
    const users = await this.getUsers();
    const cashiers = users.filter(user => user.role === 'cashier' && user.branchId === branchId);
    
    if (cashiers.length === 0) return [];
    
    // ØªØ­Ø¯ÙŠØ¯ Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ§Ø±ÙŠØ® Ù„Ù„ØªØ­Ù„ÙŠÙ„
    const today = new Date();
    let startDate = new Date();
    
    if (period === 'week') {
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    } else if (period === 'month') {
      startDate = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());
    } else if (period === 'quarter') {
      startDate = new Date(today.getFullYear(), today.getMonth() - 3, today.getDate());
    } else {
      startDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
    }
    
    const formattedStartDate = format(startDate, 'yyyy-MM-dd');
    const formattedEndDate = format(today, 'yyyy-MM-dd');
    
    // ØªØ­Ù„ÙŠÙ„ Ø£Ø¯Ø§Ø¡ ÙƒÙ„ ÙƒØ§Ø´ÙŠØ±
    const cashiersAnalysis = [];
    
    for (const cashier of cashiers) {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¨ÙŠØ¹Ø§Øª Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø®Ù„Ø§Ù„ Ø§Ù„ÙØªØ±Ø©
      const sales = await this.getDailySalesByBranchAndDateRange(
        branchId,
        formattedStartDate,
        formattedEndDate
      ).then(allSales => allSales.filter(sale => sale.cashierId === cashier.id));
      
      if (sales.length === 0) continue;
      
      // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙˆÙ†Ø³Ø¨Ø© Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù ÙˆØ§Ù„Ù…ØªÙˆØ³Ø·
      const totalSales = sales.reduce((sum, sale) => sum + sale.totalSales, 0);
      const avgSales = totalSales / sales.length;
      
      const totalTransactions = sales.reduce((sum, sale) => sum + sale.totalTransactions, 0);
      const avgTransactions = totalTransactions / sales.length;
      
      const avgTicket = totalSales / totalTransactions;
      
      // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ù„Øº Ø§Ù„Ù†Ù‚Ø¯ÙŠØ© (Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ø·Ù„Ù‚Ø©)
      const totalDiscrepancy = sales.reduce((sum, sale) => {
        return sum + (sale.discrepancy ? Math.abs(sale.discrepancy) : 0);
      }, 0);
      const avgDiscrepancy = sales.length > 0 ? totalDiscrepancy / sales.length : 0;
      
      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡: Ù‡Ù„ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ± ÙŠØªØ­Ø³Ù† Ø£Ùˆ ÙŠØªØ±Ø§Ø¬Ø¹ØŸ
      const trend = this.analyzeCashierTrend(sales);
      
      // ØªØ­Ù„ÙŠÙ„ Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© ÙˆØ§Ù„Ø¶Ø¹Ù
      const strengths = [];
      const weaknesses = [];
      
      if (avgTicket > 30) strengths.push('Ù‚ÙŠÙ…Ø© Ù…ØªÙˆØ³Ø· Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ø±ØªÙØ¹Ø©');
      if (avgDiscrepancy < 5) strengths.push('Ø§Ù†Ø­Ø±Ø§Ù Ù†Ù‚Ø¯ÙŠ Ù…Ù†Ø®ÙØ¶');
      if (trend.salesTrend === 'up') strengths.push('Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ØªØ­Ø³Ù†');
      
      if (avgTicket < 20) weaknesses.push('Ù‚ÙŠÙ…Ø© Ù…ØªÙˆØ³Ø· Ø§Ù„ØªØ°ÙƒØ±Ø© Ù…Ù†Ø®ÙØ¶Ø©');
      if (avgDiscrepancy > 20) weaknesses.push('Ø§Ù†Ø­Ø±Ø§Ù Ù†Ù‚Ø¯ÙŠ Ù…Ø±ØªÙØ¹');
      if (trend.salesTrend === 'down') weaknesses.push('Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙÙŠ ØªØ±Ø§Ø¬Ø¹');
      
      // ØªÙ‚Ø¯ÙŠÙ… ØªÙˆØµÙŠØ§Øª ØªØ¯Ø±ÙŠØ¨ÙŠØ©
      const trainingRecommendations = [];
      
      if (avgTicket < 20) {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…ØªÙ‚Ø§Ø·Ø¹ Ù„Ø²ÙŠØ§Ø¯Ø© Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø¨');
      }
      
      if (avgDiscrepancy > 20) {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø¯ ÙˆØ§Ù„ØªØ¯Ù‚ÙŠÙ‚ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª');
      }
      
      if (trend.salesTrend === 'down') {
        trainingRecommendations.push('ØªØ¯Ø±ÙŠØ¨ Ø¹Ù„Ù‰ Ù…Ù‡Ø§Ø±Ø§Øª Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©');
      }
      
      // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©
      const suggestedRewardPoints = this.calculateSuggestedRewardPoints(
        avgSales, avgDiscrepancy, trend.consistency
      );
      
      cashiersAnalysis.push({
        cashierId: cashier.id,
        cashierName: cashier.name,
        period,
        metrics: {
          totalSales,
          totalTransactions,
          averageDailySales: avgSales,
          averageTicket: avgTicket,
          averageDiscrepancy: avgDiscrepancy,
          daysLogged: sales.length
        },
        trends: trend,
        performance: {
          strengths,
          weaknesses,
          trainingRecommendations,
          suggestedRewardPoints
        }
      });
    }
    
    return cashiersAnalysis;
  }
  
  // ØªØ­Ù„ÙŠÙ„ Ø§ØªØ¬Ø§Ù‡ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ±
  private analyzeCashierTrend(sales: DailySales[]): any {
    if (sales.length < 3) {
      return { salesTrend: 'stable', consistency: 'medium' };
    }
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    const sortedSales = [...sales].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    // ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù†ØµÙ Ø§Ù„Ø£ÙˆÙ„ ÙˆØ§Ù„Ù†ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    const halfIndex = Math.floor(sortedSales.length / 2);
    const firstHalf = sortedSales.slice(0, halfIndex);
    const secondHalf = sortedSales.slice(halfIndex);
    
    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª Ù„ÙƒÙ„ Ù†ØµÙ
    const firstHalfAvg = firstHalf.reduce((sum, sale) => sum + sale.totalSales, 0) / firstHalf.length;
    const secondHalfAvg = secondHalf.reduce((sum, sale) => sum + sale.totalSales, 0) / secondHalf.length;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    let salesTrend = 'stable';
    if (secondHalfAvg > (firstHalfAvg * 1.1)) {
      salesTrend = 'up';
    } else if (secondHalfAvg < (firstHalfAvg * 0.9)) {
      salesTrend = 'down';
    }
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§ØªØ³Ø§Ù‚
    const allSales = sortedSales.map(sale => sale.totalSales);
    const mean = allSales.reduce((sum, val) => sum + val, 0) / allSales.length;
    
    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ
    const squaredDiffs = allSales.map(val => Math.pow(val - mean, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / squaredDiffs.length;
    const stdDev = Math.sqrt(avgSquaredDiff);
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ø®ØªÙ„Ø§Ù (CV)
    const cv = (stdDev / mean) * 100;
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§ØªØ³Ø§Ù‚ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„Ø§Ø®ØªÙ„Ø§Ù
    let consistency = 'medium';
    if (cv < 15) {
      consistency = 'high';
    } else if (cv > 30) {
      consistency = 'low';
    }
    
    return {
      salesTrend,
      consistency,
      changePercentage: ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100,
      coefficientOfVariation: cv
    };
  }
  
  // Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©
  private calculateSuggestedRewardPoints(avgSales: number, avgDiscrepancy: number, consistency: string): number {
    let points = 0;
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª
    if (avgSales > 1000) {
      points += 30;
    } else if (avgSales > 500) {
      points += 20;
    } else if (avgSales > 250) {
      points += 10;
    }
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§Ù†Ø­Ø±Ø§Ù
    if (avgDiscrepancy < 5) {
      points += 20;
    } else if (avgDiscrepancy < 20) {
      points += 10;
    }
    
    // Ù†Ù‚Ø§Ø· Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§ØªØ³Ø§Ù‚
    if (consistency === 'high') {
      points += 20;
    } else if (consistency === 'medium') {
      points += 10;
    }
    
    return points;
  }

  // ØªÙ… Ù†Ù‚Ù„ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ¸ÙŠÙØ© Ø¥Ù„Ù‰ Ø¢Ø®Ø± Ø§Ù„Ù…Ù„Ù
}

  /**
   * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙƒØ§Ø´ÙŠØ± Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ ÙˆØ§Ù„ØªØ§Ø±ÙŠØ®
   * @param branchId Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±Ø¹ (0 Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹)
   * @param date Ø§Ù„ØªØ§Ø±ÙŠØ®
   */
  async getCashierPerformance(branchId: number, date: Date): Promise<any[]> {
    const formattedDate = format(date, "yyyy-MM-dd");
    let cashiers = [];
    
    // Ø¥Ø°Ø§ ÙƒØ§Ù† branchId ÙŠØ³Ø§ÙˆÙŠ 0ØŒ Ù†Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ±ÙˆØ¹
    if (branchId === 0) {
      cashiers = (await this.getUsers()).filter(user => user.role === "cashier");
    } else {
      // ÙÙ„ØªØ±Ø© Ø§Ù„ÙƒØ§Ø´ÙŠØ±ÙŠÙ† Ø­Ø³Ø¨ Ø§Ù„ÙØ±Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯
      cashiers = (await this.getUsers()).filter(user => user.role === "cashier" && user.branchId === branchId);
    }
    
    const results = [];
    
    for (const cashier of cashiers) {
      const salesData = await this.getDailySalesByCashierAndDate(cashier.id, formattedDate);
      
      if (salesData) {
        // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙØ±Ø¹ Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªØ¬Ù…ÙŠØ¹ÙŠ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† branchId = 0
        const branch = await this.getBranch(salesData.branchId);
        
        results.push({
          cashierId: cashier.id,
          name: cashier.name,
          avatar: cashier.avatar,
          // Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„ÙØ±Ø¹ Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙƒÙˆÙ† branchId = 0 (Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„ÙØ±ÙˆØ¹)
          branchId: salesData.branchId,
          branchName: branchId === 0 ? (branch?.name || "") : undefined,
          shiftStart: salesData.shiftStart,
          shiftEnd: salesData.shiftEnd,
          totalSales: salesData.totalSales,
          discrepancy: salesData.discrepancy || 0,
          totalTransactions: salesData.totalTransactions,
          averageTicket: salesData.averageTicket,
          performance: salesData.discrepancy === 0 ? 100 : salesData.discrepancy < 0 ? 85 : 90
        });
      }
    }
    
    // ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª (ØªÙ†Ø§Ø²Ù„ÙŠÙ‹Ø§)
    results.sort((a, b) => b.totalSales - a.totalSales);
    
    return results;
  }
}

export const storage = new DatabaseStorage();